
FreeRTOS_Demo.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001a80  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000058  00800060  00001a80  00001b14  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000772  008000b8  008000b8  00001b6c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001b6c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001b9c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000408  00000000  00000000  00001bd8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004b58  00000000  00000000  00001fe0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000013fb  00000000  00000000  00006b38  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00004048  00000000  00000000  00007f33  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000b08  00000000  00000000  0000bf7c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000cebf  00000000  00000000  0000ca84  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00003cd5  00000000  00000000  00019943  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000003e8  00000000  00000000  0001d618  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  00004225  00000000  00000000  0001da00  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	29 c0       	rjmp	.+82     	; 0x54 <__ctors_end>
       2:	00 00       	nop
       4:	43 c0       	rjmp	.+134    	; 0x8c <__bad_interrupt>
       6:	00 00       	nop
       8:	41 c0       	rjmp	.+130    	; 0x8c <__bad_interrupt>
       a:	00 00       	nop
       c:	3f c0       	rjmp	.+126    	; 0x8c <__bad_interrupt>
       e:	00 00       	nop
      10:	3d c0       	rjmp	.+122    	; 0x8c <__bad_interrupt>
      12:	00 00       	nop
      14:	3b c0       	rjmp	.+118    	; 0x8c <__bad_interrupt>
      16:	00 00       	nop
      18:	39 c0       	rjmp	.+114    	; 0x8c <__bad_interrupt>
      1a:	00 00       	nop
      1c:	83 c5       	rjmp	.+2822   	; 0xb24 <__vector_7>
      1e:	00 00       	nop
      20:	35 c0       	rjmp	.+106    	; 0x8c <__bad_interrupt>
      22:	00 00       	nop
      24:	33 c0       	rjmp	.+102    	; 0x8c <__bad_interrupt>
      26:	00 00       	nop
      28:	31 c0       	rjmp	.+98     	; 0x8c <__bad_interrupt>
      2a:	00 00       	nop
      2c:	2f c0       	rjmp	.+94     	; 0x8c <__bad_interrupt>
      2e:	00 00       	nop
      30:	2d c0       	rjmp	.+90     	; 0x8c <__bad_interrupt>
      32:	00 00       	nop
      34:	2b c0       	rjmp	.+86     	; 0x8c <__bad_interrupt>
      36:	00 00       	nop
      38:	29 c0       	rjmp	.+82     	; 0x8c <__bad_interrupt>
      3a:	00 00       	nop
      3c:	27 c0       	rjmp	.+78     	; 0x8c <__bad_interrupt>
      3e:	00 00       	nop
      40:	3b c0       	rjmp	.+118    	; 0xb8 <__vector_16>
      42:	00 00       	nop
      44:	23 c0       	rjmp	.+70     	; 0x8c <__bad_interrupt>
      46:	00 00       	nop
      48:	21 c0       	rjmp	.+66     	; 0x8c <__bad_interrupt>
      4a:	00 00       	nop
      4c:	1f c0       	rjmp	.+62     	; 0x8c <__bad_interrupt>
      4e:	00 00       	nop
      50:	1d c0       	rjmp	.+58     	; 0x8c <__bad_interrupt>
	...

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e0 e8       	ldi	r30, 0x80	; 128
      68:	fa e1       	ldi	r31, 0x1A	; 26
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a8 3b       	cpi	r26, 0xB8	; 184
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	28 e0       	ldi	r18, 0x08	; 8
      78:	a8 eb       	ldi	r26, 0xB8	; 184
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	aa 32       	cpi	r26, 0x2A	; 42
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	31 d1       	rcall	.+610    	; 0x2ea <main>
      88:	0c 94 3e 0d 	jmp	0x1a7c	; 0x1a7c <_exit>

0000008c <__bad_interrupt>:
      8c:	b9 cf       	rjmp	.-142    	; 0x0 <__vectors>

0000008e <ADCIni>:

#include "ADCIni.h"

void ADCIni(void)
{
	DDRA = 0x00; //ADC as INPUT
      8e:	1a ba       	out	0x1a, r1	; 26
	sei();
      90:	78 94       	sei
	ADCSRA |= (1<<ADEN); //Enable ADC //Always do this FIRST
      92:	86 b1       	in	r24, 0x06	; 6
      94:	80 68       	ori	r24, 0x80	; 128
      96:	86 b9       	out	0x06, r24	; 6
	ADMUX |= AVCC; //Choose reference voltage
      98:	87 b1       	in	r24, 0x07	; 7
      9a:	80 64       	ori	r24, 0x40	; 64
      9c:	87 b9       	out	0x07, r24	; 7
	ADCSRA |= (1<<ADIE); //Enable AD Interrupt
      9e:	86 b1       	in	r24, 0x06	; 6
      a0:	88 60       	ori	r24, 0x08	; 8
      a2:	86 b9       	out	0x06, r24	; 6
	ADCSRA |= (1<<ADPS2)|(1<<ADPS0); //Division factor: 32
      a4:	86 b1       	in	r24, 0x06	; 6
      a6:	85 60       	ori	r24, 0x05	; 5
      a8:	86 b9       	out	0x06, r24	; 6
      aa:	08 95       	ret

000000ac <readAD>:
}
void readAD(uint8_t pinADC) //Read out a ADC value at a pin
{
	ADMUX = AVCC|pinADC; //Enable single output at pin
      ac:	80 64       	ori	r24, 0x40	; 64
      ae:	87 b9       	out	0x07, r24	; 7
	ADCSRA |= (1<<ADSC); //Start ADC
      b0:	86 b1       	in	r24, 0x06	; 6
      b2:	80 64       	ori	r24, 0x40	; 64
      b4:	86 b9       	out	0x06, r24	; 6
      b6:	08 95       	ret

000000b8 <__vector_16>:
}

ISR(ADC_vect)
{
      b8:	1f 92       	push	r1
      ba:	0f 92       	push	r0
      bc:	0f b6       	in	r0, 0x3f	; 63
      be:	0f 92       	push	r0
      c0:	11 24       	eor	r1, r1
      c2:	2f 93       	push	r18
      c4:	8f 93       	push	r24
      c6:	9f 93       	push	r25
	uint8_t lowAD = ADCL;
      c8:	24 b1       	in	r18, 0x04	; 4
	uint8_t hiAD = ADCH;
      ca:	85 b1       	in	r24, 0x05	; 5
	ADCresult = hiAD<<8|lowAD;
      cc:	90 e0       	ldi	r25, 0x00	; 0
      ce:	98 2f       	mov	r25, r24
      d0:	88 27       	eor	r24, r24
      d2:	82 2b       	or	r24, r18
      d4:	90 93 28 08 	sts	0x0828, r25	; 0x800828 <ADCresult+0x1>
      d8:	80 93 27 08 	sts	0x0827, r24	; 0x800827 <ADCresult>
      dc:	9f 91       	pop	r25
      de:	8f 91       	pop	r24
      e0:	2f 91       	pop	r18
      e2:	0f 90       	pop	r0
      e4:	0f be       	out	0x3f, r0	; 63
      e6:	0f 90       	pop	r0
      e8:	1f 90       	pop	r1
      ea:	18 95       	reti

000000ec <ButtonInit>:

#include "Button.h"

void ButtonInit(void)
{
	Button_DDR &= ~(1<<ButtonP);	//Buttons as INPUT
      ec:	87 b3       	in	r24, 0x17	; 23
      ee:	8f 77       	andi	r24, 0x7F	; 127
      f0:	87 bb       	out	0x17, r24	; 23
	ButtonPullup |= (1<<ButtonP);	//Enable pull-up
      f2:	88 b3       	in	r24, 0x18	; 24
      f4:	80 68       	ori	r24, 0x80	; 128
      f6:	88 bb       	out	0x18, r24	; 24
      f8:	08 95       	ret

000000fa <Buzzer_Init>:
#include <util/delay.h>
#include "Buzzer.h"

void Buzzer_Init(void)
{
	Buzzer_DDR |= (1<<Buzzer_Pin); //Buzzer pin0 as OUTPUT
      fa:	87 b3       	in	r24, 0x17	; 23
      fc:	81 60       	ori	r24, 0x01	; 1
      fe:	87 bb       	out	0x17, r24	; 23
	Buzzer |= (1<<Buzzer_Pin); //Buzzer active LOW
     100:	88 b3       	in	r24, 0x18	; 24
     102:	81 60       	ori	r24, 0x01	; 1
     104:	88 bb       	out	0x18, r24	; 24
     106:	08 95       	ret

00000108 <Lcd4_Write_Instruction>:
	Lcd4_SetString(intStr);
}
//----------Local functions----------//
static void Lcd4_Write_Instruction()
{
	LCD_DATA &= ~RS;
     108:	82 b3       	in	r24, 0x12	; 18
     10a:	8e 7f       	andi	r24, 0xFE	; 254
     10c:	82 bb       	out	0x12, r24	; 18
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     10e:	87 ec       	ldi	r24, 0xC7	; 199
     110:	90 e0       	ldi	r25, 0x00	; 0
     112:	01 97       	sbiw	r24, 0x01	; 1
     114:	f1 f7       	brne	.-4      	; 0x112 <Lcd4_Write_Instruction+0xa>
     116:	00 c0       	rjmp	.+0      	; 0x118 <Lcd4_Write_Instruction+0x10>
     118:	00 00       	nop
	_delay_us(delay_time);
	LCD_DATA &= ~RW;
     11a:	82 b3       	in	r24, 0x12	; 18
     11c:	8d 7f       	andi	r24, 0xFD	; 253
     11e:	82 bb       	out	0x12, r24	; 18
     120:	87 ec       	ldi	r24, 0xC7	; 199
     122:	90 e0       	ldi	r25, 0x00	; 0
     124:	01 97       	sbiw	r24, 0x01	; 1
     126:	f1 f7       	brne	.-4      	; 0x124 <Lcd4_Write_Instruction+0x1c>
     128:	00 c0       	rjmp	.+0      	; 0x12a <Lcd4_Write_Instruction+0x22>
     12a:	00 00       	nop
     12c:	08 95       	ret

0000012e <Lcd4_Write_Data>:
	_delay_us(delay_time);
}
static void Lcd4_Write_Data()
{
	LCD_DATA |= RS;
     12e:	82 b3       	in	r24, 0x12	; 18
     130:	81 60       	ori	r24, 0x01	; 1
     132:	82 bb       	out	0x12, r24	; 18
     134:	87 ec       	ldi	r24, 0xC7	; 199
     136:	90 e0       	ldi	r25, 0x00	; 0
     138:	01 97       	sbiw	r24, 0x01	; 1
     13a:	f1 f7       	brne	.-4      	; 0x138 <Lcd4_Write_Data+0xa>
     13c:	00 c0       	rjmp	.+0      	; 0x13e <Lcd4_Write_Data+0x10>
     13e:	00 00       	nop
	_delay_us(delay_time);
	LCD_DATA &= ~RW;
     140:	82 b3       	in	r24, 0x12	; 18
     142:	8d 7f       	andi	r24, 0xFD	; 253
     144:	82 bb       	out	0x12, r24	; 18
     146:	87 ec       	ldi	r24, 0xC7	; 199
     148:	90 e0       	ldi	r25, 0x00	; 0
     14a:	01 97       	sbiw	r24, 0x01	; 1
     14c:	f1 f7       	brne	.-4      	; 0x14a <Lcd4_Write_Data+0x1c>
     14e:	00 c0       	rjmp	.+0      	; 0x150 <Lcd4_Write_Data+0x22>
     150:	00 00       	nop
     152:	08 95       	ret

00000154 <Lcd4_Execute>:
	_delay_us(delay_time);
}
static void Lcd4_Execute(uint8_t data)					//Load data to the LCD
{
	if(data & 1) LCD_DATA|=(1<<4);	//1 = 0b00000001
     154:	80 ff       	sbrs	r24, 0
     156:	04 c0       	rjmp	.+8      	; 0x160 <Lcd4_Execute+0xc>
     158:	92 b3       	in	r25, 0x12	; 18
     15a:	90 61       	ori	r25, 0x10	; 16
     15c:	92 bb       	out	0x12, r25	; 18
     15e:	03 c0       	rjmp	.+6      	; 0x166 <Lcd4_Execute+0x12>
	else LCD_DATA&=~(1<<4);
     160:	92 b3       	in	r25, 0x12	; 18
     162:	9f 7e       	andi	r25, 0xEF	; 239
     164:	92 bb       	out	0x12, r25	; 18
	if(data & 2) LCD_DATA|=(1<<5);	//1 = 0b00000010
     166:	81 ff       	sbrs	r24, 1
     168:	04 c0       	rjmp	.+8      	; 0x172 <Lcd4_Execute+0x1e>
     16a:	92 b3       	in	r25, 0x12	; 18
     16c:	90 62       	ori	r25, 0x20	; 32
     16e:	92 bb       	out	0x12, r25	; 18
     170:	03 c0       	rjmp	.+6      	; 0x178 <Lcd4_Execute+0x24>
	else LCD_DATA&=~(1<<5);
     172:	92 b3       	in	r25, 0x12	; 18
     174:	9f 7d       	andi	r25, 0xDF	; 223
     176:	92 bb       	out	0x12, r25	; 18
	if(data & 4) LCD_DATA|=(1<<6);	//1 = 0b00000100
     178:	82 ff       	sbrs	r24, 2
     17a:	04 c0       	rjmp	.+8      	; 0x184 <Lcd4_Execute+0x30>
     17c:	92 b3       	in	r25, 0x12	; 18
     17e:	90 64       	ori	r25, 0x40	; 64
     180:	92 bb       	out	0x12, r25	; 18
     182:	03 c0       	rjmp	.+6      	; 0x18a <Lcd4_Execute+0x36>
	else LCD_DATA&=~(1<<6);
     184:	92 b3       	in	r25, 0x12	; 18
     186:	9f 7b       	andi	r25, 0xBF	; 191
     188:	92 bb       	out	0x12, r25	; 18
	if(data & 8) LCD_DATA|=(1<<7);	//1 = 0b00001000
     18a:	83 ff       	sbrs	r24, 3
     18c:	04 c0       	rjmp	.+8      	; 0x196 <Lcd4_Execute+0x42>
     18e:	82 b3       	in	r24, 0x12	; 18
     190:	80 68       	ori	r24, 0x80	; 128
     192:	82 bb       	out	0x12, r24	; 18
     194:	03 c0       	rjmp	.+6      	; 0x19c <Lcd4_Execute+0x48>
	else LCD_DATA&=~(1<<7);
     196:	82 b3       	in	r24, 0x12	; 18
     198:	8f 77       	andi	r24, 0x7F	; 127
     19a:	82 bb       	out	0x12, r24	; 18

	LCD_DATA |= E;	//Execute instruction
     19c:	82 b3       	in	r24, 0x12	; 18
     19e:	84 60       	ori	r24, 0x04	; 4
     1a0:	82 bb       	out	0x12, r24	; 18
     1a2:	87 ec       	ldi	r24, 0xC7	; 199
     1a4:	90 e0       	ldi	r25, 0x00	; 0
     1a6:	01 97       	sbiw	r24, 0x01	; 1
     1a8:	f1 f7       	brne	.-4      	; 0x1a6 <Lcd4_Execute+0x52>
     1aa:	00 c0       	rjmp	.+0      	; 0x1ac <Lcd4_Execute+0x58>
     1ac:	00 00       	nop
	_delay_us(delay_time);
	LCD_DATA &= ~E;
     1ae:	82 b3       	in	r24, 0x12	; 18
     1b0:	8b 7f       	andi	r24, 0xFB	; 251
     1b2:	82 bb       	out	0x12, r24	; 18
     1b4:	87 ec       	ldi	r24, 0xC7	; 199
     1b6:	90 e0       	ldi	r25, 0x00	; 0
     1b8:	01 97       	sbiw	r24, 0x01	; 1
     1ba:	f1 f7       	brne	.-4      	; 0x1b8 <Lcd4_Execute+0x64>
     1bc:	00 c0       	rjmp	.+0      	; 0x1be <Lcd4_Execute+0x6a>
     1be:	00 00       	nop
     1c0:	08 95       	ret

000001c2 <Lcd4_Cmd>:
	_delay_us(delay_time);

}
static void Lcd4_Cmd(uint8_t cmd)						//Send a command
{
     1c2:	cf 93       	push	r28
	Lcd4_Write_Instruction();
     1c4:	c8 2f       	mov	r28, r24
	Lcd4_Execute(cmd>>4);
     1c6:	a0 df       	rcall	.-192    	; 0x108 <Lcd4_Write_Instruction>
     1c8:	8c 2f       	mov	r24, r28
     1ca:	82 95       	swap	r24
	Lcd4_Execute(cmd&0x0F);
     1cc:	8f 70       	andi	r24, 0x0F	; 15
     1ce:	c2 df       	rcall	.-124    	; 0x154 <Lcd4_Execute>
     1d0:	8c 2f       	mov	r24, r28
     1d2:	8f 70       	andi	r24, 0x0F	; 15
     1d4:	bf df       	rcall	.-130    	; 0x154 <Lcd4_Execute>
     1d6:	cf 91       	pop	r28
     1d8:	08 95       	ret

000001da <Lcd4_Clear>:
static void Lcd4_Cmd(uint8_t cmd);						//Send a command

//----------Main functions for use----------//
void Lcd4_Clear()								//Clear screen
{
	Lcd4_Cmd(1);
     1da:	81 e0       	ldi	r24, 0x01	; 1
     1dc:	f2 df       	rcall	.-28     	; 0x1c2 <Lcd4_Cmd>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     1de:	8f e3       	ldi	r24, 0x3F	; 63
     1e0:	9f e1       	ldi	r25, 0x1F	; 31
     1e2:	01 97       	sbiw	r24, 0x01	; 1
     1e4:	f1 f7       	brne	.-4      	; 0x1e2 <Lcd4_Clear+0x8>
     1e6:	00 c0       	rjmp	.+0      	; 0x1e8 <Lcd4_Clear+0xe>
     1e8:	00 00       	nop
     1ea:	08 95       	ret

000001ec <Lcd4_Cursor>:
	_delay_ms(2);
}
void Lcd4_Cursor(uint8_t row, uint8_t column)	//Set DDRAM(cursor) address --- 0b1(ADD6:0)
{
	char temp;
	if(row == 1)
     1ec:	81 30       	cpi	r24, 0x01	; 1
     1ee:	21 f4       	brne	.+8      	; 0x1f8 <Lcd4_Cursor+0xc>
	{
		temp = 0b10000000 + (column-1);
		Lcd4_Cmd(temp);
     1f0:	8f e7       	ldi	r24, 0x7F	; 127
     1f2:	86 0f       	add	r24, r22
     1f4:	e6 cf       	rjmp	.-52     	; 0x1c2 <Lcd4_Cmd>
     1f6:	08 95       	ret
	}
	else if(row == 2)
     1f8:	82 30       	cpi	r24, 0x02	; 2
     1fa:	19 f4       	brne	.+6      	; 0x202 <Lcd4_Cursor+0x16>
	{
		temp = 0b11000000 + (column-1);
		Lcd4_Cmd(temp);
     1fc:	8f eb       	ldi	r24, 0xBF	; 191
     1fe:	86 0f       	add	r24, r22
     200:	e0 cf       	rjmp	.-64     	; 0x1c2 <Lcd4_Cmd>
     202:	08 95       	ret

00000204 <Lcd4_Ini>:
	}
}
void Lcd4_Ini(void)								//Initialize LCD
{
	LCD_DDR = 0xFF;
     204:	8f ef       	ldi	r24, 0xFF	; 255
     206:	81 bb       	out	0x11, r24	; 17
     208:	2f ef       	ldi	r18, 0xFF	; 255
     20a:	89 ef       	ldi	r24, 0xF9	; 249
     20c:	90 e0       	ldi	r25, 0x00	; 0
     20e:	21 50       	subi	r18, 0x01	; 1
     210:	80 40       	sbci	r24, 0x00	; 0
     212:	90 40       	sbci	r25, 0x00	; 0
     214:	e1 f7       	brne	.-8      	; 0x20e <Lcd4_Ini+0xa>
     216:	00 c0       	rjmp	.+0      	; 0x218 <Lcd4_Ini+0x14>
     218:	00 00       	nop
	//----------Reset process from data sheet----------//
	_delay_ms(20);	//Wait for more than 15ms after VCC=4.5V
	Lcd4_Cmd(0x03);
     21a:	83 e0       	ldi	r24, 0x03	; 3
     21c:	d2 df       	rcall	.-92     	; 0x1c2 <Lcd4_Cmd>
     21e:	8f e1       	ldi	r24, 0x1F	; 31
     220:	9e e4       	ldi	r25, 0x4E	; 78
     222:	01 97       	sbiw	r24, 0x01	; 1
     224:	f1 f7       	brne	.-4      	; 0x222 <Lcd4_Ini+0x1e>
     226:	00 c0       	rjmp	.+0      	; 0x228 <Lcd4_Ini+0x24>
	_delay_ms(5);	//Wait for more than 4.1ms
	Lcd4_Cmd(0x03);
     228:	00 00       	nop
     22a:	83 e0       	ldi	r24, 0x03	; 3
     22c:	ca df       	rcall	.-108    	; 0x1c2 <Lcd4_Cmd>
     22e:	8f e9       	ldi	r24, 0x9F	; 159
     230:	9f e0       	ldi	r25, 0x0F	; 15
     232:	01 97       	sbiw	r24, 0x01	; 1
     234:	f1 f7       	brne	.-4      	; 0x232 <Lcd4_Ini+0x2e>
	_delay_ms(1);	//Wait for more than 100us
	Lcd4_Cmd(0x03);
     236:	00 c0       	rjmp	.+0      	; 0x238 <Lcd4_Ini+0x34>
	//--------------------//
	Lcd4_Cmd(0x02);	//Function set: 4bit
     238:	00 00       	nop
	Lcd4_Cmd(0x28);	//Function set: 4bit, 2 lines, 5x8 font		---	0b001DNF** (D:data length,N:no. of line,F:font)
     23a:	83 e0       	ldi	r24, 0x03	; 3
     23c:	c2 df       	rcall	.-124    	; 0x1c2 <Lcd4_Cmd>
	Lcd4_Cmd(0x0C); //Display control: display ON	--- 0b00001DCB (D:display,C:cursor,B:blinking)
     23e:	82 e0       	ldi	r24, 0x02	; 2
     240:	c0 df       	rcall	.-128    	; 0x1c2 <Lcd4_Cmd>
     242:	88 e2       	ldi	r24, 0x28	; 40
	Lcd4_Cmd(0x06); //Entry mode set: increment, no accompany	--- 0b000001IS (I:increment/decrement,S:acc. display shift)
     244:	be df       	rcall	.-132    	; 0x1c2 <Lcd4_Cmd>
     246:	8c e0       	ldi	r24, 0x0C	; 12
     248:	bc df       	rcall	.-136    	; 0x1c2 <Lcd4_Cmd>
     24a:	86 e0       	ldi	r24, 0x06	; 6
     24c:	ba cf       	rjmp	.-140    	; 0x1c2 <Lcd4_Cmd>
     24e:	08 95       	ret

00000250 <Lcd4_SetChar>:
}
void Lcd4_SetChar(char character)				//Send a single character
{
     250:	cf 93       	push	r28
	Lcd4_Write_Data();
     252:	c8 2f       	mov	r28, r24

	Lcd4_Execute(character>>4); //Data transfer
     254:	6c df       	rcall	.-296    	; 0x12e <Lcd4_Write_Data>
     256:	8c 2f       	mov	r24, r28
     258:	82 95       	swap	r24
	Lcd4_Execute(character&0x0F);
     25a:	8f 70       	andi	r24, 0x0F	; 15
     25c:	7b df       	rcall	.-266    	; 0x154 <Lcd4_Execute>
     25e:	8c 2f       	mov	r24, r28
}
     260:	8f 70       	andi	r24, 0x0F	; 15
     262:	78 df       	rcall	.-272    	; 0x154 <Lcd4_Execute>
     264:	cf 91       	pop	r28
     266:	08 95       	ret

00000268 <Lcd4_SetString>:
void Lcd4_SetString(char *pStr)					//Send a string
{
     268:	cf 93       	push	r28
     26a:	df 93       	push	r29
     26c:	ec 01       	movw	r28, r24
	while(*pStr>0) //Whenever pointer gets to the end, *pStr = 0
     26e:	02 c0       	rjmp	.+4      	; 0x274 <Lcd4_SetString+0xc>
	Lcd4_SetChar(*pStr++); //Send individual char and increase pointer address
     270:	21 96       	adiw	r28, 0x01	; 1
     272:	ee df       	rcall	.-36     	; 0x250 <Lcd4_SetChar>
	Lcd4_Execute(character>>4); //Data transfer
	Lcd4_Execute(character&0x0F);
}
void Lcd4_SetString(char *pStr)					//Send a string
{
	while(*pStr>0) //Whenever pointer gets to the end, *pStr = 0
     274:	88 81       	ld	r24, Y
     276:	81 11       	cpse	r24, r1
     278:	fb cf       	rjmp	.-10     	; 0x270 <Lcd4_SetString+0x8>
	Lcd4_SetChar(*pStr++); //Send individual char and increase pointer address
}
     27a:	df 91       	pop	r29
     27c:	cf 91       	pop	r28
     27e:	08 95       	ret

00000280 <Lcd4_SetNum>:
void Lcd4_SetNum(uint16_t integer)				//Send a number as string (max 4 digits)
{
     280:	0f 93       	push	r16
     282:	1f 93       	push	r17
     284:	cf 93       	push	r28
     286:	df 93       	push	r29
     288:	00 d0       	rcall	.+0      	; 0x28a <Lcd4_SetNum+0xa>
     28a:	00 d0       	rcall	.+0      	; 0x28c <Lcd4_SetNum+0xc>
     28c:	1f 92       	push	r1
     28e:	cd b7       	in	r28, 0x3d	; 61
     290:	de b7       	in	r29, 0x3e	; 62
     292:	8c 01       	movw	r16, r24
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
     294:	4a e0       	ldi	r20, 0x0A	; 10
     296:	be 01       	movw	r22, r28
     298:	6f 5f       	subi	r22, 0xFF	; 255
     29a:	7f 4f       	sbci	r23, 0xFF	; 255
     29c:	0e 94 0b 0d 	call	0x1a16	; 0x1a16 <__itoa_ncheck>
	char intStr[5];

	itoa(integer, intStr, 10);
	if (integer<10)		{Lcd4_SetString("000");}
     2a0:	0a 30       	cpi	r16, 0x0A	; 10
     2a2:	11 05       	cpc	r17, r1
     2a4:	20 f4       	brcc	.+8      	; 0x2ae <Lcd4_SetNum+0x2e>
     2a6:	80 e6       	ldi	r24, 0x60	; 96
     2a8:	90 e0       	ldi	r25, 0x00	; 0
     2aa:	de df       	rcall	.-68     	; 0x268 <Lcd4_SetString>
     2ac:	0d c0       	rjmp	.+26     	; 0x2c8 <Lcd4_SetNum+0x48>
	else if (integer<100)	{Lcd4_SetString("00");}
     2ae:	04 36       	cpi	r16, 0x64	; 100
     2b0:	11 05       	cpc	r17, r1
     2b2:	20 f4       	brcc	.+8      	; 0x2bc <Lcd4_SetNum+0x3c>
     2b4:	81 e6       	ldi	r24, 0x61	; 97
     2b6:	90 e0       	ldi	r25, 0x00	; 0
     2b8:	d7 df       	rcall	.-82     	; 0x268 <Lcd4_SetString>
     2ba:	06 c0       	rjmp	.+12     	; 0x2c8 <Lcd4_SetNum+0x48>
	else if (integer<1000)	{Lcd4_SetString("0");}
     2bc:	08 3e       	cpi	r16, 0xE8	; 232
     2be:	13 40       	sbci	r17, 0x03	; 3
     2c0:	18 f4       	brcc	.+6      	; 0x2c8 <Lcd4_SetNum+0x48>
     2c2:	82 e6       	ldi	r24, 0x62	; 98
	Lcd4_SetString(intStr);
     2c4:	90 e0       	ldi	r25, 0x00	; 0
     2c6:	d0 df       	rcall	.-96     	; 0x268 <Lcd4_SetString>
     2c8:	ce 01       	movw	r24, r28
     2ca:	01 96       	adiw	r24, 0x01	; 1
}
     2cc:	cd df       	rcall	.-102    	; 0x268 <Lcd4_SetString>
     2ce:	0f 90       	pop	r0
     2d0:	0f 90       	pop	r0
     2d2:	0f 90       	pop	r0
     2d4:	0f 90       	pop	r0
     2d6:	0f 90       	pop	r0
     2d8:	df 91       	pop	r29
     2da:	cf 91       	pop	r28
     2dc:	1f 91       	pop	r17
     2de:	0f 91       	pop	r16
     2e0:	08 95       	ret

000002e2 <vLEDInit>:
#include "LED.h"

void vLEDInit(void)
{
// Set LED1 as output pin
	LED1_DDR |=	0xFF;
     2e2:	84 b3       	in	r24, 0x14	; 20
     2e4:	8f ef       	ldi	r24, 0xFF	; 255
     2e6:	84 bb       	out	0x14, r24	; 20
     2e8:	08 95       	ret

000002ea <main>:
portSHORT main(void)
{
	vLEDInit();
	ADCIni();
	Lcd4_Ini();
	Lcd4_Clear();
     2ea:	fb df       	rcall	.-10     	; 0x2e2 <vLEDInit>
     2ec:	d0 de       	rcall	.-608    	; 0x8e <ADCIni>
	Buzzer_Init();
     2ee:	8a df       	rcall	.-236    	; 0x204 <Lcd4_Ini>
	ButtonInit();
     2f0:	74 df       	rcall	.-280    	; 0x1da <Lcd4_Clear>
     2f2:	03 df       	rcall	.-506    	; 0xfa <Buzzer_Init>
	//
	xADCQueue = xQueueCreate(1, sizeof(uint16_t));
     2f4:	fb de       	rcall	.-522    	; 0xec <ButtonInit>
     2f6:	40 e0       	ldi	r20, 0x00	; 0
     2f8:	62 e0       	ldi	r22, 0x02	; 2
     2fa:	81 e0       	ldi	r24, 0x01	; 1
     2fc:	48 d5       	rcall	.+2704   	; 0xd8e <xQueueGenericCreate>
     2fe:	90 93 be 00 	sts	0x00BE, r25	; 0x8000be <xADCQueue+0x1>
     302:	80 93 bd 00 	sts	0x00BD, r24	; 0x8000bd <xADCQueue>
	//
	xTaskCreate(vLEDFlashTask, "LED0", configMINIMAL_STACK_SIZE, NULL, mainLED_PRIORITY, NULL );
     306:	e1 2c       	mov	r14, r1
     308:	f1 2c       	mov	r15, r1
     30a:	00 e0       	ldi	r16, 0x00	; 0
     30c:	20 e0       	ldi	r18, 0x00	; 0
     30e:	30 e0       	ldi	r19, 0x00	; 0
     310:	46 e9       	ldi	r20, 0x96	; 150
     312:	50 e0       	ldi	r21, 0x00	; 0
     314:	64 e6       	ldi	r22, 0x64	; 100
     316:	70 e0       	ldi	r23, 0x00	; 0
     318:	83 ed       	ldi	r24, 0xD3	; 211
     31a:	91 e0       	ldi	r25, 0x01	; 1
     31c:	c9 d7       	rcall	.+3986   	; 0x12b0 <xTaskCreate>
	xTaskCreate(vLCDPrintString1, "LCD0", configMINIMAL_STACK_SIZE, (void*) thisString, mainLCD_PRIORITY, NULL);
     31e:	01 e0       	ldi	r16, 0x01	; 1
     320:	29 e6       	ldi	r18, 0x69	; 105
     322:	30 e0       	ldi	r19, 0x00	; 0
     324:	46 e9       	ldi	r20, 0x96	; 150
     326:	50 e0       	ldi	r21, 0x00	; 0
     328:	63 e7       	ldi	r22, 0x73	; 115
     32a:	70 e0       	ldi	r23, 0x00	; 0
     32c:	80 e6       	ldi	r24, 0x60	; 96
     32e:	92 e0       	ldi	r25, 0x02	; 2
	xTaskCreate(vLCDPrintCounting, "LCD1", configMINIMAL_STACK_SIZE, NULL, mainLCD_PRIORITY, NULL);
     330:	bf d7       	rcall	.+3966   	; 0x12b0 <xTaskCreate>
     332:	20 e0       	ldi	r18, 0x00	; 0
     334:	30 e0       	ldi	r19, 0x00	; 0
     336:	46 e9       	ldi	r20, 0x96	; 150
     338:	50 e0       	ldi	r21, 0x00	; 0
     33a:	68 e7       	ldi	r22, 0x78	; 120
     33c:	70 e0       	ldi	r23, 0x00	; 0
     33e:	85 e7       	ldi	r24, 0x75	; 117
     340:	92 e0       	ldi	r25, 0x02	; 2
	xTaskCreate(vLCDPrintADC, "LCD2", configMINIMAL_STACK_SIZE, NULL, mainLCD_PRIORITY, NULL);
     342:	b6 d7       	rcall	.+3948   	; 0x12b0 <xTaskCreate>
     344:	20 e0       	ldi	r18, 0x00	; 0
     346:	30 e0       	ldi	r19, 0x00	; 0
     348:	46 e9       	ldi	r20, 0x96	; 150
     34a:	50 e0       	ldi	r21, 0x00	; 0
     34c:	6d e7       	ldi	r22, 0x7D	; 125
     34e:	70 e0       	ldi	r23, 0x00	; 0
     350:	8f e8       	ldi	r24, 0x8F	; 143
     352:	92 e0       	ldi	r25, 0x02	; 2
	xTaskCreate(vADCGetValue, "ADC0", configMINIMAL_STACK_SIZE, NULL, mainADC_PRIORITY, NULL);
     354:	ad d7       	rcall	.+3930   	; 0x12b0 <xTaskCreate>
     356:	02 e0       	ldi	r16, 0x02	; 2
     358:	20 e0       	ldi	r18, 0x00	; 0
     35a:	30 e0       	ldi	r19, 0x00	; 0
     35c:	46 e9       	ldi	r20, 0x96	; 150
     35e:	50 e0       	ldi	r21, 0x00	; 0
     360:	62 e8       	ldi	r22, 0x82	; 130
     362:	70 e0       	ldi	r23, 0x00	; 0
     364:	86 e0       	ldi	r24, 0x06	; 6
     366:	93 e0       	ldi	r25, 0x03	; 3
     368:	a3 d7       	rcall	.+3910   	; 0x12b0 <xTaskCreate>
	xTaskCreate(vBuzzerFromButton, "Buzzer0",  configMINIMAL_STACK_SIZE, NULL, mainBUTTON_PRIORITY+1, &vBuzzerButtonHandle);
     36a:	0f 2e       	mov	r0, r31
     36c:	fb eb       	ldi	r31, 0xBB	; 187
     36e:	ef 2e       	mov	r14, r31
     370:	f0 e0       	ldi	r31, 0x00	; 0
     372:	ff 2e       	mov	r15, r31
     374:	f0 2d       	mov	r31, r0
     376:	04 e0       	ldi	r16, 0x04	; 4
     378:	20 e0       	ldi	r18, 0x00	; 0
     37a:	30 e0       	ldi	r19, 0x00	; 0
     37c:	46 e9       	ldi	r20, 0x96	; 150
     37e:	50 e0       	ldi	r21, 0x00	; 0
     380:	67 e8       	ldi	r22, 0x87	; 135
     382:	70 e0       	ldi	r23, 0x00	; 0
     384:	85 e8       	ldi	r24, 0x85	; 133
     386:	93 e0       	ldi	r25, 0x03	; 3
	xTaskCreate(vButton, "Button0", configMINIMAL_STACK_SIZE, NULL, mainBUTTON_PRIORITY, NULL);
     388:	93 d7       	rcall	.+3878   	; 0x12b0 <xTaskCreate>
     38a:	e1 2c       	mov	r14, r1
     38c:	f1 2c       	mov	r15, r1
     38e:	03 e0       	ldi	r16, 0x03	; 3
     390:	20 e0       	ldi	r18, 0x00	; 0
     392:	30 e0       	ldi	r19, 0x00	; 0
     394:	46 e9       	ldi	r20, 0x96	; 150
     396:	50 e0       	ldi	r21, 0x00	; 0
     398:	6f e8       	ldi	r22, 0x8F	; 143
     39a:	70 e0       	ldi	r23, 0x00	; 0
     39c:	8b e4       	ldi	r24, 0x4B	; 75
     39e:	93 e0       	ldi	r25, 0x03	; 3
	//start scheduler
	vTaskStartScheduler();
     3a0:	87 d7       	rcall	.+3854   	; 0x12b0 <xTaskCreate>
     3a2:	d5 d7       	rcall	.+4010   	; 0x134e <vTaskStartScheduler>
     3a4:	ff cf       	rjmp	.-2      	; 0x3a4 <main+0xba>

000003a6 <vLEDFlashTask>:

QueueHandle_t xADCQueue = 0;
TaskHandle_t vBuzzerButtonHandle = NULL;

void vLEDFlashTask( void *pvParameters )
{
     3a6:	cf 93       	push	r28
     3a8:	df 93       	push	r29
     3aa:	00 d0       	rcall	.+0      	; 0x3ac <vLEDFlashTask+0x6>
     3ac:	cd b7       	in	r28, 0x3d	; 61
	portTickType lastWake = xTaskGetTickCount();
     3ae:	de b7       	in	r29, 0x3e	; 62
     3b0:	fc d7       	rcall	.+4088   	; 0x13aa <xTaskGetTickCount>
     3b2:	9a 83       	std	Y+2, r25	; 0x02
	uint8_t i;

	for( ;; )
	{
		for (i=0;i<7;i++)
     3b4:	89 83       	std	Y+1, r24	; 0x01
     3b6:	10 e0       	ldi	r17, 0x00	; 0
		{
			LED1^= 0xFF;
     3b8:	0a c0       	rjmp	.+20     	; 0x3ce <vLEDFlashTask+0x28>
     3ba:	85 b3       	in	r24, 0x15	; 21
     3bc:	80 95       	com	r24
			vTaskDelayUntil(&lastWake, pdMS_TO_TICKS(100));
     3be:	85 bb       	out	0x15, r24	; 21
     3c0:	6a e0       	ldi	r22, 0x0A	; 10
     3c2:	70 e0       	ldi	r23, 0x00	; 0
     3c4:	ce 01       	movw	r24, r28
     3c6:	01 96       	adiw	r24, 0x01	; 1
     3c8:	0e 94 01 0b 	call	0x1602	; 0x1602 <vTaskDelayUntil>
	portTickType lastWake = xTaskGetTickCount();
	uint8_t i;

	for( ;; )
	{
		for (i=0;i<7;i++)
     3cc:	1f 5f       	subi	r17, 0xFF	; 255
     3ce:	17 30       	cpi	r17, 0x07	; 7
		{
			LED1^= 0xFF;
			vTaskDelayUntil(&lastWake, pdMS_TO_TICKS(100));
		}
		LED1=0;
     3d0:	a0 f3       	brcs	.-24     	; 0x3ba <vLEDFlashTask+0x14>
		for (i=0;i<7;i++)
     3d2:	15 ba       	out	0x15, r1	; 21
     3d4:	10 e0       	ldi	r17, 0x00	; 0
		{
			LED1 = 0xAA;
     3d6:	18 c0       	rjmp	.+48     	; 0x408 <__LOCK_REGION_LENGTH__+0x8>
     3d8:	8a ea       	ldi	r24, 0xAA	; 170
			vTaskDelayUntil(&lastWake, pdMS_TO_TICKS(100));
     3da:	85 bb       	out	0x15, r24	; 21
     3dc:	6a e0       	ldi	r22, 0x0A	; 10
     3de:	70 e0       	ldi	r23, 0x00	; 0
     3e0:	ce 01       	movw	r24, r28
     3e2:	01 96       	adiw	r24, 0x01	; 1
     3e4:	0e 94 01 0b 	call	0x1602	; 0x1602 <vTaskDelayUntil>
			LED1 = 0;
			vTaskDelayUntil(&lastWake, pdMS_TO_TICKS(100));
     3e8:	15 ba       	out	0x15, r1	; 21
     3ea:	6a e0       	ldi	r22, 0x0A	; 10
     3ec:	70 e0       	ldi	r23, 0x00	; 0
     3ee:	ce 01       	movw	r24, r28
     3f0:	01 96       	adiw	r24, 0x01	; 1
     3f2:	0e 94 01 0b 	call	0x1602	; 0x1602 <vTaskDelayUntil>
			LED1 = 0x55;
     3f6:	85 e5       	ldi	r24, 0x55	; 85
			vTaskDelayUntil(&lastWake, pdMS_TO_TICKS(100));
     3f8:	85 bb       	out	0x15, r24	; 21
     3fa:	6a e0       	ldi	r22, 0x0A	; 10
     3fc:	70 e0       	ldi	r23, 0x00	; 0
     3fe:	ce 01       	movw	r24, r28
     400:	01 96       	adiw	r24, 0x01	; 1
     402:	0e 94 01 0b 	call	0x1602	; 0x1602 <vTaskDelayUntil>
		{
			LED1^= 0xFF;
			vTaskDelayUntil(&lastWake, pdMS_TO_TICKS(100));
		}
		LED1=0;
		for (i=0;i<7;i++)
     406:	1f 5f       	subi	r17, 0xFF	; 255
     408:	17 30       	cpi	r17, 0x07	; 7
			LED1 = 0;
			vTaskDelayUntil(&lastWake, pdMS_TO_TICKS(100));
			LED1 = 0x55;
			vTaskDelayUntil(&lastWake, pdMS_TO_TICKS(100));
		}
		LED1=0;
     40a:	30 f3       	brcs	.-52     	; 0x3d8 <vLEDFlashTask+0x32>
		for (i=0;i<7;i++)
     40c:	15 ba       	out	0x15, r1	; 21
     40e:	10 e0       	ldi	r17, 0x00	; 0
		{
			LED1=(1<<i);
     410:	10 c0       	rjmp	.+32     	; 0x432 <__LOCK_REGION_LENGTH__+0x32>
     412:	81 e0       	ldi	r24, 0x01	; 1
     414:	90 e0       	ldi	r25, 0x00	; 0
     416:	01 2e       	mov	r0, r17
     418:	02 c0       	rjmp	.+4      	; 0x41e <__LOCK_REGION_LENGTH__+0x1e>
     41a:	88 0f       	add	r24, r24
     41c:	99 1f       	adc	r25, r25
     41e:	0a 94       	dec	r0
     420:	e2 f7       	brpl	.-8      	; 0x41a <__LOCK_REGION_LENGTH__+0x1a>
			vTaskDelayUntil(&lastWake, pdMS_TO_TICKS(100));
     422:	85 bb       	out	0x15, r24	; 21
     424:	6a e0       	ldi	r22, 0x0A	; 10
     426:	70 e0       	ldi	r23, 0x00	; 0
     428:	ce 01       	movw	r24, r28
     42a:	01 96       	adiw	r24, 0x01	; 1
     42c:	0e 94 01 0b 	call	0x1602	; 0x1602 <vTaskDelayUntil>
			vTaskDelayUntil(&lastWake, pdMS_TO_TICKS(100));
			LED1 = 0x55;
			vTaskDelayUntil(&lastWake, pdMS_TO_TICKS(100));
		}
		LED1=0;
		for (i=0;i<7;i++)
     430:	1f 5f       	subi	r17, 0xFF	; 255
     432:	17 30       	cpi	r17, 0x07	; 7
		{
			LED1=(1<<i);
			vTaskDelayUntil(&lastWake, pdMS_TO_TICKS(100));
		}
		LED1=0;
     434:	70 f3       	brcs	.-36     	; 0x412 <__LOCK_REGION_LENGTH__+0x12>
		for (i=0;i<7;i++)
     436:	15 ba       	out	0x15, r1	; 21
     438:	10 e0       	ldi	r17, 0x00	; 0
		{
			LED1=(0x80>>i);
     43a:	10 c0       	rjmp	.+32     	; 0x45c <__LOCK_REGION_LENGTH__+0x5c>
     43c:	80 e8       	ldi	r24, 0x80	; 128
     43e:	90 e0       	ldi	r25, 0x00	; 0
     440:	01 2e       	mov	r0, r17
     442:	02 c0       	rjmp	.+4      	; 0x448 <__LOCK_REGION_LENGTH__+0x48>
     444:	95 95       	asr	r25
     446:	87 95       	ror	r24
     448:	0a 94       	dec	r0
     44a:	e2 f7       	brpl	.-8      	; 0x444 <__LOCK_REGION_LENGTH__+0x44>
			vTaskDelayUntil(&lastWake, pdMS_TO_TICKS(100));
     44c:	85 bb       	out	0x15, r24	; 21
     44e:	6a e0       	ldi	r22, 0x0A	; 10
     450:	70 e0       	ldi	r23, 0x00	; 0
     452:	ce 01       	movw	r24, r28
     454:	01 96       	adiw	r24, 0x01	; 1
     456:	0e 94 01 0b 	call	0x1602	; 0x1602 <vTaskDelayUntil>
		{
			LED1=(1<<i);
			vTaskDelayUntil(&lastWake, pdMS_TO_TICKS(100));
		}
		LED1=0;
		for (i=0;i<7;i++)
     45a:	1f 5f       	subi	r17, 0xFF	; 255
     45c:	17 30       	cpi	r17, 0x07	; 7
		{
			LED1=(0x80>>i);
			vTaskDelayUntil(&lastWake, pdMS_TO_TICKS(100));
		}
		LED1=0;
     45e:	70 f3       	brcs	.-36     	; 0x43c <__LOCK_REGION_LENGTH__+0x3c>
		for (i=0;i<7;i++)
     460:	15 ba       	out	0x15, r1	; 21
     462:	10 e0       	ldi	r17, 0x00	; 0
		{
			LED1|=(1<<i);
     464:	12 c0       	rjmp	.+36     	; 0x48a <__LOCK_REGION_LENGTH__+0x8a>
     466:	25 b3       	in	r18, 0x15	; 21
     468:	81 e0       	ldi	r24, 0x01	; 1
     46a:	90 e0       	ldi	r25, 0x00	; 0
     46c:	01 2e       	mov	r0, r17
     46e:	02 c0       	rjmp	.+4      	; 0x474 <__LOCK_REGION_LENGTH__+0x74>
     470:	88 0f       	add	r24, r24
     472:	99 1f       	adc	r25, r25
     474:	0a 94       	dec	r0
     476:	e2 f7       	brpl	.-8      	; 0x470 <__LOCK_REGION_LENGTH__+0x70>
     478:	82 2b       	or	r24, r18
			vTaskDelayUntil(&lastWake, pdMS_TO_TICKS(100));
     47a:	85 bb       	out	0x15, r24	; 21
     47c:	6a e0       	ldi	r22, 0x0A	; 10
     47e:	70 e0       	ldi	r23, 0x00	; 0
     480:	ce 01       	movw	r24, r28
     482:	01 96       	adiw	r24, 0x01	; 1
     484:	0e 94 01 0b 	call	0x1602	; 0x1602 <vTaskDelayUntil>
		{
			LED1=(0x80>>i);
			vTaskDelayUntil(&lastWake, pdMS_TO_TICKS(100));
		}
		LED1=0;
		for (i=0;i<7;i++)
     488:	1f 5f       	subi	r17, 0xFF	; 255
     48a:	17 30       	cpi	r17, 0x07	; 7
		{
			LED1|=(1<<i);
			vTaskDelayUntil(&lastWake, pdMS_TO_TICKS(100));
		}
		LED1=0;
     48c:	60 f3       	brcs	.-40     	; 0x466 <__LOCK_REGION_LENGTH__+0x66>
		for (i=0;i<7;i++)
     48e:	15 ba       	out	0x15, r1	; 21
     490:	10 e0       	ldi	r17, 0x00	; 0
		{
			LED1|=(0X80>>i);
     492:	12 c0       	rjmp	.+36     	; 0x4b8 <__LOCK_REGION_LENGTH__+0xb8>
     494:	25 b3       	in	r18, 0x15	; 21
     496:	80 e8       	ldi	r24, 0x80	; 128
     498:	90 e0       	ldi	r25, 0x00	; 0
     49a:	01 2e       	mov	r0, r17
     49c:	02 c0       	rjmp	.+4      	; 0x4a2 <__LOCK_REGION_LENGTH__+0xa2>
     49e:	95 95       	asr	r25
     4a0:	87 95       	ror	r24
     4a2:	0a 94       	dec	r0
     4a4:	e2 f7       	brpl	.-8      	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>
     4a6:	82 2b       	or	r24, r18
			vTaskDelayUntil(&lastWake, pdMS_TO_TICKS(100));
     4a8:	85 bb       	out	0x15, r24	; 21
     4aa:	6a e0       	ldi	r22, 0x0A	; 10
     4ac:	70 e0       	ldi	r23, 0x00	; 0
     4ae:	ce 01       	movw	r24, r28
     4b0:	01 96       	adiw	r24, 0x01	; 1
     4b2:	0e 94 01 0b 	call	0x1602	; 0x1602 <vTaskDelayUntil>
		{
			LED1|=(1<<i);
			vTaskDelayUntil(&lastWake, pdMS_TO_TICKS(100));
		}
		LED1=0;
		for (i=0;i<7;i++)
     4b6:	1f 5f       	subi	r17, 0xFF	; 255
     4b8:	17 30       	cpi	r17, 0x07	; 7
		{
			LED1|=(0X80>>i);
			vTaskDelayUntil(&lastWake, pdMS_TO_TICKS(100));
		}
		LED1=0;
     4ba:	60 f3       	brcs	.-40     	; 0x494 <__LOCK_REGION_LENGTH__+0x94>
	}
     4bc:	15 ba       	out	0x15, r1	; 21
     4be:	7b cf       	rjmp	.-266    	; 0x3b6 <vLEDFlashTask+0x10>

000004c0 <vLCDPrintString1>:
}

void vLCDPrintString1(void *pvParameters)
{
     4c0:	cf 93       	push	r28
     4c2:	df 93       	push	r29
     4c4:	00 d0       	rcall	.+0      	; 0x4c6 <vLCDPrintString1+0x6>
     4c6:	cd b7       	in	r28, 0x3d	; 61
     4c8:	de b7       	in	r29, 0x3e	; 62
	portTickType lastWake = xTaskGetTickCount();
     4ca:	8c 01       	movw	r16, r24
     4cc:	6e d7       	rcall	.+3804   	; 0x13aa <xTaskGetTickCount>
     4ce:	9a 83       	std	Y+2, r25	; 0x02

	printStr = (char *) pvParameters;

	for (;;)
	{
		Lcd4_Cursor(1,1);
     4d0:	89 83       	std	Y+1, r24	; 0x01
     4d2:	61 e0       	ldi	r22, 0x01	; 1
		Lcd4_SetString(printStr);
     4d4:	81 e0       	ldi	r24, 0x01	; 1
     4d6:	8a de       	rcall	.-748    	; 0x1ec <Lcd4_Cursor>
     4d8:	c8 01       	movw	r24, r16
		vTaskDelayUntil(&lastWake, pdMS_TO_TICKS(5000));
     4da:	c6 de       	rcall	.-628    	; 0x268 <Lcd4_SetString>
     4dc:	69 e2       	ldi	r22, 0x29	; 41
     4de:	70 e0       	ldi	r23, 0x00	; 0
     4e0:	ce 01       	movw	r24, r28
     4e2:	01 96       	adiw	r24, 0x01	; 1
     4e4:	0e 94 01 0b 	call	0x1602	; 0x1602 <vTaskDelayUntil>
     4e8:	f4 cf       	rjmp	.-24     	; 0x4d2 <vLCDPrintString1+0x12>

000004ea <vLCDPrintCounting>:
	}

}

void vLCDPrintCounting(void *pvParameters)
{
     4ea:	cf 93       	push	r28
     4ec:	df 93       	push	r29
     4ee:	00 d0       	rcall	.+0      	; 0x4f0 <vLCDPrintCounting+0x6>
     4f0:	cd b7       	in	r28, 0x3d	; 61
	portTickType lastWake = xTaskGetTickCount();
     4f2:	de b7       	in	r29, 0x3e	; 62
     4f4:	5a d7       	rcall	.+3764   	; 0x13aa <xTaskGetTickCount>
     4f6:	9a 83       	std	Y+2, r25	; 0x02
	static uint8_t counter=0;

	for(;;)
	{
		Lcd4_Cursor(1,13);
     4f8:	89 83       	std	Y+1, r24	; 0x01
     4fa:	6d e0       	ldi	r22, 0x0D	; 13
     4fc:	81 e0       	ldi	r24, 0x01	; 1
		Lcd4_SetNum(counter++);
     4fe:	76 de       	rcall	.-788    	; 0x1ec <Lcd4_Cursor>
     500:	80 91 ba 00 	lds	r24, 0x00BA	; 0x8000ba <counter.2380>
     504:	91 e0       	ldi	r25, 0x01	; 1
     506:	98 0f       	add	r25, r24
     508:	90 93 ba 00 	sts	0x00BA, r25	; 0x8000ba <counter.2380>
     50c:	90 e0       	ldi	r25, 0x00	; 0
		vTaskDelayUntil(&lastWake, pdMS_TO_TICKS(1000));
     50e:	b8 de       	rcall	.-656    	; 0x280 <Lcd4_SetNum>
     510:	62 e2       	ldi	r22, 0x22	; 34
     512:	70 e0       	ldi	r23, 0x00	; 0
     514:	ce 01       	movw	r24, r28
     516:	01 96       	adiw	r24, 0x01	; 1
     518:	0e 94 01 0b 	call	0x1602	; 0x1602 <vTaskDelayUntil>
     51c:	ee cf       	rjmp	.-36     	; 0x4fa <vLCDPrintCounting+0x10>

0000051e <vLCDPrintADC>:
	}
}

void vLCDPrintADC(void *pvParameters)
{
     51e:	cf 93       	push	r28
     520:	df 93       	push	r29
     522:	00 d0       	rcall	.+0      	; 0x524 <vLCDPrintADC+0x6>
     524:	00 d0       	rcall	.+0      	; 0x526 <vLCDPrintADC+0x8>
     526:	cd b7       	in	r28, 0x3d	; 61
	portTickType lastWake = xTaskGetTickCount();
     528:	de b7       	in	r29, 0x3e	; 62
     52a:	3f d7       	rcall	.+3710   	; 0x13aa <xTaskGetTickCount>
     52c:	9a 83       	std	Y+2, r25	; 0x02
	uint16_t ADCQueueValue_Get;

	for(;;)
	{
		xQueueReceive(xADCQueue, &ADCQueueValue_Get, 100);	//Receive vaule from the task ADC0
     52e:	89 83       	std	Y+1, r24	; 0x01
     530:	20 e0       	ldi	r18, 0x00	; 0
     532:	44 e6       	ldi	r20, 0x64	; 100
     534:	50 e0       	ldi	r21, 0x00	; 0
     536:	be 01       	movw	r22, r28
     538:	6d 5f       	subi	r22, 0xFD	; 253
     53a:	7f 4f       	sbci	r23, 0xFF	; 255
     53c:	80 91 bd 00 	lds	r24, 0x00BD	; 0x8000bd <xADCQueue>
     540:	90 91 be 00 	lds	r25, 0x00BE	; 0x8000be <xADCQueue+0x1>
		Lcd4_Cursor(2,9);
     544:	ce d4       	rcall	.+2460   	; 0xee2 <xQueueGenericReceive>
     546:	69 e0       	ldi	r22, 0x09	; 9

		if(ADCQueueValue_Get==0)
     548:	82 e0       	ldi	r24, 0x02	; 2
     54a:	50 de       	rcall	.-864    	; 0x1ec <Lcd4_Cursor>
     54c:	8b 81       	ldd	r24, Y+3	; 0x03
		{
			Lcd4_SetString("________");
     54e:	9c 81       	ldd	r25, Y+4	; 0x04
     550:	00 97       	sbiw	r24, 0x00	; 0
     552:	21 f4       	brne	.+8      	; 0x55c <vLCDPrintADC+0x3e>
     554:	87 e9       	ldi	r24, 0x97	; 151
     556:	90 e0       	ldi	r25, 0x00	; 0
		}
		else if(ADCQueueValue_Get<128)
     558:	87 de       	rcall	.-754    	; 0x268 <Lcd4_SetString>
     55a:	52 c0       	rjmp	.+164    	; 0x600 <vLCDPrintADC+0xe2>
		{
			Lcd4_SetString("*");
     55c:	80 38       	cpi	r24, 0x80	; 128
     55e:	91 05       	cpc	r25, r1
     560:	38 f4       	brcc	.+14     	; 0x570 <vLCDPrintADC+0x52>
			Lcd4_SetString("_______");
     562:	87 ea       	ldi	r24, 0xA7	; 167
     564:	90 e0       	ldi	r25, 0x00	; 0
     566:	80 de       	rcall	.-768    	; 0x268 <Lcd4_SetString>
     568:	88 e9       	ldi	r24, 0x98	; 152
		}
		else if(ADCQueueValue_Get<(128*2))
     56a:	90 e0       	ldi	r25, 0x00	; 0
     56c:	7d de       	rcall	.-774    	; 0x268 <Lcd4_SetString>
		{
			Lcd4_SetString("**");
     56e:	48 c0       	rjmp	.+144    	; 0x600 <vLCDPrintADC+0xe2>
     570:	8f 3f       	cpi	r24, 0xFF	; 255
     572:	91 05       	cpc	r25, r1
     574:	09 f0       	breq	.+2      	; 0x578 <vLCDPrintADC+0x5a>
			Lcd4_SetString("______");
     576:	38 f4       	brcc	.+14     	; 0x586 <vLCDPrintADC+0x68>
     578:	86 ea       	ldi	r24, 0xA6	; 166
     57a:	90 e0       	ldi	r25, 0x00	; 0
     57c:	75 de       	rcall	.-790    	; 0x268 <Lcd4_SetString>
		}
		else if(ADCQueueValue_Get<(128*3))
     57e:	89 e9       	ldi	r24, 0x99	; 153
     580:	90 e0       	ldi	r25, 0x00	; 0
     582:	72 de       	rcall	.-796    	; 0x268 <Lcd4_SetString>
		{
			Lcd4_SetString("***");
     584:	3d c0       	rjmp	.+122    	; 0x600 <vLCDPrintADC+0xe2>
     586:	80 38       	cpi	r24, 0x80	; 128
     588:	21 e0       	ldi	r18, 0x01	; 1
     58a:	92 07       	cpc	r25, r18
			Lcd4_SetString("_____");
     58c:	38 f4       	brcc	.+14     	; 0x59c <vLCDPrintADC+0x7e>
     58e:	85 ea       	ldi	r24, 0xA5	; 165
     590:	90 e0       	ldi	r25, 0x00	; 0
		}
		else if(ADCQueueValue_Get<(128*4))
     592:	6a de       	rcall	.-812    	; 0x268 <Lcd4_SetString>
     594:	8a e9       	ldi	r24, 0x9A	; 154
     596:	90 e0       	ldi	r25, 0x00	; 0
     598:	67 de       	rcall	.-818    	; 0x268 <Lcd4_SetString>
		{
			Lcd4_SetString("****");
     59a:	32 c0       	rjmp	.+100    	; 0x600 <vLCDPrintADC+0xe2>
     59c:	81 15       	cp	r24, r1
     59e:	22 e0       	ldi	r18, 0x02	; 2
			Lcd4_SetString("____");
     5a0:	92 07       	cpc	r25, r18
     5a2:	38 f4       	brcc	.+14     	; 0x5b2 <vLCDPrintADC+0x94>
     5a4:	84 ea       	ldi	r24, 0xA4	; 164
     5a6:	90 e0       	ldi	r25, 0x00	; 0
		}
		else if(ADCQueueValue_Get<(128*5))
     5a8:	5f de       	rcall	.-834    	; 0x268 <Lcd4_SetString>
     5aa:	8b e9       	ldi	r24, 0x9B	; 155
     5ac:	90 e0       	ldi	r25, 0x00	; 0
     5ae:	5c de       	rcall	.-840    	; 0x268 <Lcd4_SetString>
		{
			Lcd4_SetString("*****");
     5b0:	27 c0       	rjmp	.+78     	; 0x600 <vLCDPrintADC+0xe2>
     5b2:	80 38       	cpi	r24, 0x80	; 128
			Lcd4_SetString("___");
     5b4:	22 e0       	ldi	r18, 0x02	; 2
     5b6:	92 07       	cpc	r25, r18
     5b8:	38 f4       	brcc	.+14     	; 0x5c8 <vLCDPrintADC+0xaa>
     5ba:	83 ea       	ldi	r24, 0xA3	; 163
		}
		else if(ADCQueueValue_Get<(128*6))
     5bc:	90 e0       	ldi	r25, 0x00	; 0
     5be:	54 de       	rcall	.-856    	; 0x268 <Lcd4_SetString>
     5c0:	8c e9       	ldi	r24, 0x9C	; 156
		{
			Lcd4_SetString("******");
     5c2:	90 e0       	ldi	r25, 0x00	; 0
     5c4:	51 de       	rcall	.-862    	; 0x268 <Lcd4_SetString>
     5c6:	1c c0       	rjmp	.+56     	; 0x600 <vLCDPrintADC+0xe2>
			Lcd4_SetString("__");
     5c8:	81 15       	cp	r24, r1
     5ca:	23 e0       	ldi	r18, 0x03	; 3
     5cc:	92 07       	cpc	r25, r18
     5ce:	38 f4       	brcc	.+14     	; 0x5de <vLCDPrintADC+0xc0>
		}
		else if(ADCQueueValue_Get<(128*7))
     5d0:	82 ea       	ldi	r24, 0xA2	; 162
     5d2:	90 e0       	ldi	r25, 0x00	; 0
     5d4:	49 de       	rcall	.-878    	; 0x268 <Lcd4_SetString>
		{
			Lcd4_SetString("*******");
     5d6:	8d e9       	ldi	r24, 0x9D	; 157
     5d8:	90 e0       	ldi	r25, 0x00	; 0
     5da:	46 de       	rcall	.-884    	; 0x268 <Lcd4_SetString>
			Lcd4_SetString("_");
     5dc:	11 c0       	rjmp	.+34     	; 0x600 <vLCDPrintADC+0xe2>
     5de:	80 38       	cpi	r24, 0x80	; 128
     5e0:	23 e0       	ldi	r18, 0x03	; 3
     5e2:	92 07       	cpc	r25, r18
     5e4:	38 f4       	brcc	.+14     	; 0x5f4 <vLCDPrintADC+0xd6>
		}
		else if(ADCQueueValue_Get<(128*8))
     5e6:	81 ea       	ldi	r24, 0xA1	; 161
     5e8:	90 e0       	ldi	r25, 0x00	; 0
     5ea:	3e de       	rcall	.-900    	; 0x268 <Lcd4_SetString>
		{
			Lcd4_SetString("********");
     5ec:	8e e9       	ldi	r24, 0x9E	; 158
     5ee:	90 e0       	ldi	r25, 0x00	; 0
     5f0:	3b de       	rcall	.-906    	; 0x268 <Lcd4_SetString>
     5f2:	06 c0       	rjmp	.+12     	; 0x600 <vLCDPrintADC+0xe2>
		}
		vTaskDelayUntil(&lastWake, pdMS_TO_TICKS(225));
     5f4:	81 15       	cp	r24, r1
     5f6:	94 40       	sbci	r25, 0x04	; 4
     5f8:	18 f4       	brcc	.+6      	; 0x600 <vLCDPrintADC+0xe2>
     5fa:	80 ea       	ldi	r24, 0xA0	; 160
     5fc:	90 e0       	ldi	r25, 0x00	; 0
     5fe:	34 de       	rcall	.-920    	; 0x268 <Lcd4_SetString>
	}
     600:	66 e1       	ldi	r22, 0x16	; 22
     602:	70 e0       	ldi	r23, 0x00	; 0
     604:	ce 01       	movw	r24, r28
     606:	01 96       	adiw	r24, 0x01	; 1
     608:	fc d7       	rcall	.+4088   	; 0x1602 <vTaskDelayUntil>
     60a:	92 cf       	rjmp	.-220    	; 0x530 <vLCDPrintADC+0x12>

0000060c <vADCGetValue>:
}

void vADCGetValue(void *pvParameters)
{
     60c:	cf 93       	push	r28
     60e:	df 93       	push	r29
     610:	00 d0       	rcall	.+0      	; 0x612 <vADCGetValue+0x6>
     612:	00 d0       	rcall	.+0      	; 0x614 <vADCGetValue+0x8>
     614:	cd b7       	in	r28, 0x3d	; 61
	portTickType lastWake = xTaskGetTickCount();
     616:	de b7       	in	r29, 0x3e	; 62
     618:	c8 d6       	rcall	.+3472   	; 0x13aa <xTaskGetTickCount>
	uint16_t ADCQueueValue_Send;

	for(;;)
	{
		readAD(0);
     61a:	9a 83       	std	Y+2, r25	; 0x02
		Lcd4_Cursor(2,1);
     61c:	89 83       	std	Y+1, r24	; 0x01
     61e:	80 e0       	ldi	r24, 0x00	; 0
     620:	45 dd       	rcall	.-1398   	; 0xac <readAD>
		Lcd4_SetNum(ADCresult);
     622:	61 e0       	ldi	r22, 0x01	; 1
     624:	82 e0       	ldi	r24, 0x02	; 2
     626:	e2 dd       	rcall	.-1084   	; 0x1ec <Lcd4_Cursor>
     628:	80 91 27 08 	lds	r24, 0x0827	; 0x800827 <ADCresult>
		ADCQueueValue_Send = ADCresult;
     62c:	90 91 28 08 	lds	r25, 0x0828	; 0x800828 <ADCresult+0x1>
     630:	27 de       	rcall	.-946    	; 0x280 <Lcd4_SetNum>
     632:	80 91 27 08 	lds	r24, 0x0827	; 0x800827 <ADCresult>
     636:	90 91 28 08 	lds	r25, 0x0828	; 0x800828 <ADCresult+0x1>
		xQueueSend(xADCQueue, &ADCQueueValue_Send, 0);	//Send vaule to the task LCD2
     63a:	9c 83       	std	Y+4, r25	; 0x04
     63c:	8b 83       	std	Y+3, r24	; 0x03
     63e:	20 e0       	ldi	r18, 0x00	; 0
     640:	40 e0       	ldi	r20, 0x00	; 0
     642:	50 e0       	ldi	r21, 0x00	; 0
     644:	be 01       	movw	r22, r28
     646:	6d 5f       	subi	r22, 0xFD	; 253
     648:	7f 4f       	sbci	r23, 0xFF	; 255
     64a:	80 91 bd 00 	lds	r24, 0x00BD	; 0x8000bd <xADCQueue>
		if (ADCQueueValue_Send>=1000)
     64e:	90 91 be 00 	lds	r25, 0x00BE	; 0x8000be <xADCQueue+0x1>
     652:	c5 d3       	rcall	.+1930   	; 0xdde <xQueueGenericSend>
     654:	8b 81       	ldd	r24, Y+3	; 0x03
     656:	9c 81       	ldd	r25, Y+4	; 0x04
     658:	88 3e       	cpi	r24, 0xE8	; 232
		{
			for(uint8_t i=0; i<50; i++)
			{
				Buzzer ^= (1<<Buzzer_Pin);
     65a:	93 40       	sbci	r25, 0x03	; 3
     65c:	60 f4       	brcc	.+24     	; 0x676 <vADCGetValue+0x6a>
     65e:	12 c0       	rjmp	.+36     	; 0x684 <vADCGetValue+0x78>
				vTaskDelayUntil(&lastWake, pdMS_TO_TICKS(20));
     660:	98 b3       	in	r25, 0x18	; 24
     662:	81 e0       	ldi	r24, 0x01	; 1
     664:	89 27       	eor	r24, r25
     666:	88 bb       	out	0x18, r24	; 24
     668:	62 e0       	ldi	r22, 0x02	; 2
     66a:	70 e0       	ldi	r23, 0x00	; 0
		Lcd4_SetNum(ADCresult);
		ADCQueueValue_Send = ADCresult;
		xQueueSend(xADCQueue, &ADCQueueValue_Send, 0);	//Send vaule to the task LCD2
		if (ADCQueueValue_Send>=1000)
		{
			for(uint8_t i=0; i<50; i++)
     66c:	ce 01       	movw	r24, r28
     66e:	01 96       	adiw	r24, 0x01	; 1
     670:	c8 d7       	rcall	.+3984   	; 0x1602 <vTaskDelayUntil>
     672:	1f 5f       	subi	r17, 0xFF	; 255
     674:	01 c0       	rjmp	.+2      	; 0x678 <vADCGetValue+0x6c>
			{
				Buzzer ^= (1<<Buzzer_Pin);
				vTaskDelayUntil(&lastWake, pdMS_TO_TICKS(20));
			}
			Buzzer |= (1<<Buzzer_Pin);
     676:	10 e0       	ldi	r17, 0x00	; 0
     678:	12 33       	cpi	r17, 0x32	; 50
     67a:	90 f3       	brcs	.-28     	; 0x660 <vADCGetValue+0x54>
     67c:	88 b3       	in	r24, 0x18	; 24
		}
		else
		{
			Buzzer |= (1<<Buzzer_Pin);
     67e:	81 60       	ori	r24, 0x01	; 1
     680:	88 bb       	out	0x18, r24	; 24
		}
		//xTaskNotify(vBuzzerADCHandle, ADCQueueValue_Send, eSetValueWithoutOverwrite);
		vTaskDelayUntil(&lastWake, pdMS_TO_TICKS(200));
     682:	03 c0       	rjmp	.+6      	; 0x68a <vADCGetValue+0x7e>
     684:	88 b3       	in	r24, 0x18	; 24
     686:	81 60       	ori	r24, 0x01	; 1
     688:	88 bb       	out	0x18, r24	; 24
     68a:	64 e1       	ldi	r22, 0x14	; 20
     68c:	70 e0       	ldi	r23, 0x00	; 0
	}
     68e:	ce 01       	movw	r24, r28
     690:	01 96       	adiw	r24, 0x01	; 1
     692:	b7 d7       	rcall	.+3950   	; 0x1602 <vTaskDelayUntil>
     694:	c4 cf       	rjmp	.-120    	; 0x61e <vADCGetValue+0x12>

00000696 <vButton>:
}

void vButton(void *pvParameters)
{
     696:	cf 93       	push	r28
     698:	df 93       	push	r29
     69a:	00 d0       	rcall	.+0      	; 0x69c <vButton+0x6>
     69c:	cd b7       	in	r28, 0x3d	; 61
	portTickType lastWake = xTaskGetTickCount();
     69e:	de b7       	in	r29, 0x3e	; 62
     6a0:	84 d6       	rcall	.+3336   	; 0x13aa <xTaskGetTickCount>
     6a2:	9a 83       	std	Y+2, r25	; 0x02

static inline void debounce(void)
{
	static uint8_t count = 0;	// Counter for number of equal states
	static uint8_t button_state = 0;	// Keeps track of current (debounced)state
	uint8_t current_state = (~ButtonPin & (1<<ButtonP));	// Check if button is high or low for the moment
     6a4:	89 83       	std	Y+1, r24	; 0x01
     6a6:	86 b3       	in	r24, 0x16	; 22
     6a8:	80 95       	com	r24

	if (current_state != button_state)
     6aa:	80 78       	andi	r24, 0x80	; 128
     6ac:	90 91 b9 00 	lds	r25, 0x00B9	; 0x8000b9 <button_state.2342>
     6b0:	89 17       	cp	r24, r25
	{
		count++;		// Button state is about to be changed, increase counter
     6b2:	89 f0       	breq	.+34     	; 0x6d6 <vButton+0x40>
     6b4:	90 91 b8 00 	lds	r25, 0x00B8	; 0x8000b8 <__data_end>
     6b8:	9f 5f       	subi	r25, 0xFF	; 255
     6ba:	90 93 b8 00 	sts	0x00B8, r25	; 0x8000b8 <__data_end>
		if (count >= 5)
     6be:	95 30       	cpi	r25, 0x05	; 5
		{
			button_state = current_state;	// The button have not bounced for four checks, change state
     6c0:	60 f0       	brcs	.+24     	; 0x6da <vButton+0x44>
     6c2:	80 93 b9 00 	sts	0x00B9, r24	; 0x8000b9 <button_state.2342>
			if (current_state != 0)			// If the button was pressed (not released), tell main so
     6c6:	88 23       	and	r24, r24
			{
				button_down = 1;
     6c8:	19 f0       	breq	.+6      	; 0x6d0 <vButton+0x3a>
     6ca:	81 e0       	ldi	r24, 0x01	; 1
     6cc:	80 93 29 08 	sts	0x0829, r24	; 0x800829 <button_down>
			}
			count = 0;
     6d0:	10 92 b8 00 	sts	0x00B8, r1	; 0x8000b8 <__data_end>
		}
	}
	else
	{
		count = 0;		// Reset counter
     6d4:	02 c0       	rjmp	.+4      	; 0x6da <vButton+0x44>
     6d6:	10 92 b8 00 	sts	0x00B8, r1	; 0x8000b8 <__data_end>

	for(;;)
	{
		debounce();
		if (button_down)
     6da:	80 91 29 08 	lds	r24, 0x0829	; 0x800829 <button_down>
     6de:	88 23       	and	r24, r24
		{
			button_down = 0;
     6e0:	71 f0       	breq	.+28     	; 0x6fe <vButton+0x68>
     6e2:	10 92 29 08 	sts	0x0829, r1	; 0x800829 <button_down>
			xTaskNotifyGive(vBuzzerButtonHandle);
     6e6:	00 e0       	ldi	r16, 0x00	; 0
     6e8:	10 e0       	ldi	r17, 0x00	; 0
     6ea:	22 e0       	ldi	r18, 0x02	; 2
     6ec:	40 e0       	ldi	r20, 0x00	; 0
     6ee:	50 e0       	ldi	r21, 0x00	; 0
     6f0:	ba 01       	movw	r22, r20
     6f2:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <vBuzzerButtonHandle>
     6f6:	90 91 bc 00 	lds	r25, 0x00BC	; 0x8000bc <vBuzzerButtonHandle+0x1>
     6fa:	0e 94 7d 0c 	call	0x18fa	; 0x18fa <xTaskGenericNotify>
		}
		vTaskDelayUntil(&lastWake, pdMS_TO_TICKS(10));
     6fe:	61 e0       	ldi	r22, 0x01	; 1
     700:	70 e0       	ldi	r23, 0x00	; 0
     702:	ce 01       	movw	r24, r28
     704:	01 96       	adiw	r24, 0x01	; 1
	}
     706:	7d d7       	rcall	.+3834   	; 0x1602 <vTaskDelayUntil>
     708:	ce cf       	rjmp	.-100    	; 0x6a6 <vButton+0x10>

0000070a <vBuzzerFromButton>:
}

void vBuzzerFromButton(void *pvParameters)
{
     70a:	cf 93       	push	r28
     70c:	df 93       	push	r29
     70e:	00 d0       	rcall	.+0      	; 0x710 <vBuzzerFromButton+0x6>
     710:	cd b7       	in	r28, 0x3d	; 61
	portTickType lastWake = xTaskGetTickCount();
     712:	de b7       	in	r29, 0x3e	; 62
     714:	4a d6       	rcall	.+3220   	; 0x13aa <xTaskGetTickCount>
     716:	9a 83       	std	Y+2, r25	; 0x02

	for(;;)
	{
		if (0 != ulTaskNotifyTake(pdFALSE, pdMS_TO_TICKS(20)))
     718:	89 83       	std	Y+1, r24	; 0x01
     71a:	62 e0       	ldi	r22, 0x02	; 2
     71c:	70 e0       	ldi	r23, 0x00	; 0
     71e:	80 e0       	ldi	r24, 0x00	; 0
     720:	0e 94 28 0c 	call	0x1850	; 0x1850 <ulTaskNotifyTake>
     724:	67 2b       	or	r22, r23
     726:	68 2b       	or	r22, r24
     728:	69 2b       	or	r22, r25
		{
			Lcd4_Cursor(1,1);
     72a:	c1 f0       	breq	.+48     	; 0x75c <vBuzzerFromButton+0x52>
     72c:	61 e0       	ldi	r22, 0x01	; 1
			Lcd4_SetString("Notified!");
     72e:	81 e0       	ldi	r24, 0x01	; 1
     730:	5d dd       	rcall	.-1350   	; 0x1ec <Lcd4_Cursor>
     732:	89 ea       	ldi	r24, 0xA9	; 169
			for(uint8_t i=0; i<20; i++)
     734:	90 e0       	ldi	r25, 0x00	; 0
     736:	98 dd       	rcall	.-1232   	; 0x268 <Lcd4_SetString>
			{
				Buzzer ^= (1<<Buzzer_Pin);
     738:	10 e0       	ldi	r17, 0x00	; 0
     73a:	0a c0       	rjmp	.+20     	; 0x750 <vBuzzerFromButton+0x46>
     73c:	98 b3       	in	r25, 0x18	; 24
     73e:	81 e0       	ldi	r24, 0x01	; 1
				vTaskDelayUntil(&lastWake, pdMS_TO_TICKS(75));
     740:	89 27       	eor	r24, r25
     742:	88 bb       	out	0x18, r24	; 24
     744:	67 e0       	ldi	r22, 0x07	; 7
     746:	70 e0       	ldi	r23, 0x00	; 0
     748:	ce 01       	movw	r24, r28
	{
		if (0 != ulTaskNotifyTake(pdFALSE, pdMS_TO_TICKS(20)))
		{
			Lcd4_Cursor(1,1);
			Lcd4_SetString("Notified!");
			for(uint8_t i=0; i<20; i++)
     74a:	01 96       	adiw	r24, 0x01	; 1
     74c:	5a d7       	rcall	.+3764   	; 0x1602 <vTaskDelayUntil>
     74e:	1f 5f       	subi	r17, 0xFF	; 255
			{
				Buzzer ^= (1<<Buzzer_Pin);
				vTaskDelayUntil(&lastWake, pdMS_TO_TICKS(75));
			}
			Buzzer |= (1<<Buzzer_Pin);
     750:	14 31       	cpi	r17, 0x14	; 20
     752:	a0 f3       	brcs	.-24     	; 0x73c <vBuzzerFromButton+0x32>
     754:	88 b3       	in	r24, 0x18	; 24
     756:	81 60       	ori	r24, 0x01	; 1
		}
		else
		{
			Buzzer |= (1<<Buzzer_Pin);
     758:	88 bb       	out	0x18, r24	; 24
     75a:	df cf       	rjmp	.-66     	; 0x71a <vBuzzerFromButton+0x10>
     75c:	88 b3       	in	r24, 0x18	; 24
     75e:	81 60       	ori	r24, 0x01	; 1
     760:	88 bb       	out	0x18, r24	; 24
     762:	db cf       	rjmp	.-74     	; 0x71a <vBuzzerFromButton+0x10>

00000764 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     764:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     766:	03 96       	adiw	r24, 0x03	; 3
     768:	92 83       	std	Z+2, r25	; 0x02
     76a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     76c:	2f ef       	ldi	r18, 0xFF	; 255
     76e:	3f ef       	ldi	r19, 0xFF	; 255
     770:	34 83       	std	Z+4, r19	; 0x04
     772:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     774:	96 83       	std	Z+6, r25	; 0x06
     776:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     778:	90 87       	std	Z+8, r25	; 0x08
     77a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     77c:	10 82       	st	Z, r1
     77e:	08 95       	ret

00000780 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     780:	fc 01       	movw	r30, r24
     782:	11 86       	std	Z+9, r1	; 0x09
     784:	10 86       	std	Z+8, r1	; 0x08
     786:	08 95       	ret

00000788 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     788:	cf 93       	push	r28
     78a:	df 93       	push	r29
     78c:	9c 01       	movw	r18, r24
     78e:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     790:	dc 01       	movw	r26, r24
     792:	11 96       	adiw	r26, 0x01	; 1
     794:	cd 91       	ld	r28, X+
     796:	dc 91       	ld	r29, X
     798:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     79a:	d3 83       	std	Z+3, r29	; 0x03
     79c:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     79e:	8c 81       	ldd	r24, Y+4	; 0x04
     7a0:	9d 81       	ldd	r25, Y+5	; 0x05
     7a2:	95 83       	std	Z+5, r25	; 0x05
     7a4:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     7a6:	8c 81       	ldd	r24, Y+4	; 0x04
     7a8:	9d 81       	ldd	r25, Y+5	; 0x05
     7aa:	dc 01       	movw	r26, r24
     7ac:	13 96       	adiw	r26, 0x03	; 3
     7ae:	7c 93       	st	X, r23
     7b0:	6e 93       	st	-X, r22
     7b2:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     7b4:	7d 83       	std	Y+5, r23	; 0x05
     7b6:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     7b8:	31 87       	std	Z+9, r19	; 0x09
     7ba:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     7bc:	f9 01       	movw	r30, r18
     7be:	80 81       	ld	r24, Z
     7c0:	8f 5f       	subi	r24, 0xFF	; 255
     7c2:	80 83       	st	Z, r24
}
     7c4:	df 91       	pop	r29
     7c6:	cf 91       	pop	r28
     7c8:	08 95       	ret

000007ca <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     7ca:	cf 93       	push	r28
     7cc:	df 93       	push	r29
     7ce:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     7d0:	48 81       	ld	r20, Y
     7d2:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     7d4:	4f 3f       	cpi	r20, 0xFF	; 255
     7d6:	2f ef       	ldi	r18, 0xFF	; 255
     7d8:	52 07       	cpc	r21, r18
     7da:	21 f4       	brne	.+8      	; 0x7e4 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     7dc:	fc 01       	movw	r30, r24
     7de:	a7 81       	ldd	r26, Z+7	; 0x07
     7e0:	b0 85       	ldd	r27, Z+8	; 0x08
     7e2:	0d c0       	rjmp	.+26     	; 0x7fe <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     7e4:	dc 01       	movw	r26, r24
     7e6:	13 96       	adiw	r26, 0x03	; 3
     7e8:	01 c0       	rjmp	.+2      	; 0x7ec <vListInsert+0x22>
     7ea:	df 01       	movw	r26, r30
     7ec:	12 96       	adiw	r26, 0x02	; 2
     7ee:	ed 91       	ld	r30, X+
     7f0:	fc 91       	ld	r31, X
     7f2:	13 97       	sbiw	r26, 0x03	; 3
     7f4:	20 81       	ld	r18, Z
     7f6:	31 81       	ldd	r19, Z+1	; 0x01
     7f8:	42 17       	cp	r20, r18
     7fa:	53 07       	cpc	r21, r19
     7fc:	b0 f7       	brcc	.-20     	; 0x7ea <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     7fe:	12 96       	adiw	r26, 0x02	; 2
     800:	ed 91       	ld	r30, X+
     802:	fc 91       	ld	r31, X
     804:	13 97       	sbiw	r26, 0x03	; 3
     806:	fb 83       	std	Y+3, r31	; 0x03
     808:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     80a:	d5 83       	std	Z+5, r29	; 0x05
     80c:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     80e:	bd 83       	std	Y+5, r27	; 0x05
     810:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     812:	13 96       	adiw	r26, 0x03	; 3
     814:	dc 93       	st	X, r29
     816:	ce 93       	st	-X, r28
     818:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     81a:	99 87       	std	Y+9, r25	; 0x09
     81c:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     81e:	fc 01       	movw	r30, r24
     820:	20 81       	ld	r18, Z
     822:	2f 5f       	subi	r18, 0xFF	; 255
     824:	20 83       	st	Z, r18
}
     826:	df 91       	pop	r29
     828:	cf 91       	pop	r28
     82a:	08 95       	ret

0000082c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     82c:	cf 93       	push	r28
     82e:	df 93       	push	r29
     830:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     832:	a0 85       	ldd	r26, Z+8	; 0x08
     834:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     836:	c2 81       	ldd	r28, Z+2	; 0x02
     838:	d3 81       	ldd	r29, Z+3	; 0x03
     83a:	84 81       	ldd	r24, Z+4	; 0x04
     83c:	95 81       	ldd	r25, Z+5	; 0x05
     83e:	9d 83       	std	Y+5, r25	; 0x05
     840:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     842:	c4 81       	ldd	r28, Z+4	; 0x04
     844:	d5 81       	ldd	r29, Z+5	; 0x05
     846:	82 81       	ldd	r24, Z+2	; 0x02
     848:	93 81       	ldd	r25, Z+3	; 0x03
     84a:	9b 83       	std	Y+3, r25	; 0x03
     84c:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     84e:	11 96       	adiw	r26, 0x01	; 1
     850:	8d 91       	ld	r24, X+
     852:	9c 91       	ld	r25, X
     854:	12 97       	sbiw	r26, 0x02	; 2
     856:	e8 17       	cp	r30, r24
     858:	f9 07       	cpc	r31, r25
     85a:	31 f4       	brne	.+12     	; 0x868 <__stack+0x9>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     85c:	84 81       	ldd	r24, Z+4	; 0x04
     85e:	95 81       	ldd	r25, Z+5	; 0x05
     860:	12 96       	adiw	r26, 0x02	; 2
     862:	9c 93       	st	X, r25
     864:	8e 93       	st	-X, r24
     866:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     868:	11 86       	std	Z+9, r1	; 0x09
     86a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     86c:	8c 91       	ld	r24, X
     86e:	81 50       	subi	r24, 0x01	; 1
     870:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     872:	df 91       	pop	r29
     874:	cf 91       	pop	r28
     876:	08 95       	ret

00000878 <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     878:	89 e0       	ldi	r24, 0x09	; 9
     87a:	8b bd       	out	0x2b, r24	; 43
     87c:	83 ec       	ldi	r24, 0xC3	; 195
     87e:	8a bd       	out	0x2a, r24	; 42
     880:	8b e0       	ldi	r24, 0x0B	; 11
     882:	8e bd       	out	0x2e, r24	; 46
     884:	89 b7       	in	r24, 0x39	; 57
     886:	80 61       	ori	r24, 0x10	; 16
     888:	89 bf       	out	0x39, r24	; 57
     88a:	08 95       	ret

0000088c <pxPortInitialiseStack>:
     88c:	31 e1       	ldi	r19, 0x11	; 17
     88e:	fc 01       	movw	r30, r24
     890:	30 83       	st	Z, r19
     892:	31 97       	sbiw	r30, 0x01	; 1
     894:	22 e2       	ldi	r18, 0x22	; 34
     896:	20 83       	st	Z, r18
     898:	31 97       	sbiw	r30, 0x01	; 1
     89a:	a3 e3       	ldi	r26, 0x33	; 51
     89c:	a0 83       	st	Z, r26
     89e:	31 97       	sbiw	r30, 0x01	; 1
     8a0:	60 83       	st	Z, r22
     8a2:	31 97       	sbiw	r30, 0x01	; 1
     8a4:	70 83       	st	Z, r23
     8a6:	31 97       	sbiw	r30, 0x01	; 1
     8a8:	10 82       	st	Z, r1
     8aa:	31 97       	sbiw	r30, 0x01	; 1
     8ac:	60 e8       	ldi	r22, 0x80	; 128
     8ae:	60 83       	st	Z, r22
     8b0:	31 97       	sbiw	r30, 0x01	; 1
     8b2:	10 82       	st	Z, r1
     8b4:	31 97       	sbiw	r30, 0x01	; 1
     8b6:	62 e0       	ldi	r22, 0x02	; 2
     8b8:	60 83       	st	Z, r22
     8ba:	31 97       	sbiw	r30, 0x01	; 1
     8bc:	63 e0       	ldi	r22, 0x03	; 3
     8be:	60 83       	st	Z, r22
     8c0:	31 97       	sbiw	r30, 0x01	; 1
     8c2:	64 e0       	ldi	r22, 0x04	; 4
     8c4:	60 83       	st	Z, r22
     8c6:	31 97       	sbiw	r30, 0x01	; 1
     8c8:	65 e0       	ldi	r22, 0x05	; 5
     8ca:	60 83       	st	Z, r22
     8cc:	31 97       	sbiw	r30, 0x01	; 1
     8ce:	66 e0       	ldi	r22, 0x06	; 6
     8d0:	60 83       	st	Z, r22
     8d2:	31 97       	sbiw	r30, 0x01	; 1
     8d4:	67 e0       	ldi	r22, 0x07	; 7
     8d6:	60 83       	st	Z, r22
     8d8:	31 97       	sbiw	r30, 0x01	; 1
     8da:	68 e0       	ldi	r22, 0x08	; 8
     8dc:	60 83       	st	Z, r22
     8de:	31 97       	sbiw	r30, 0x01	; 1
     8e0:	69 e0       	ldi	r22, 0x09	; 9
     8e2:	60 83       	st	Z, r22
     8e4:	31 97       	sbiw	r30, 0x01	; 1
     8e6:	60 e1       	ldi	r22, 0x10	; 16
     8e8:	60 83       	st	Z, r22
     8ea:	31 97       	sbiw	r30, 0x01	; 1
     8ec:	30 83       	st	Z, r19
     8ee:	31 97       	sbiw	r30, 0x01	; 1
     8f0:	32 e1       	ldi	r19, 0x12	; 18
     8f2:	30 83       	st	Z, r19
     8f4:	31 97       	sbiw	r30, 0x01	; 1
     8f6:	33 e1       	ldi	r19, 0x13	; 19
     8f8:	30 83       	st	Z, r19
     8fa:	31 97       	sbiw	r30, 0x01	; 1
     8fc:	34 e1       	ldi	r19, 0x14	; 20
     8fe:	30 83       	st	Z, r19
     900:	31 97       	sbiw	r30, 0x01	; 1
     902:	35 e1       	ldi	r19, 0x15	; 21
     904:	30 83       	st	Z, r19
     906:	31 97       	sbiw	r30, 0x01	; 1
     908:	36 e1       	ldi	r19, 0x16	; 22
     90a:	30 83       	st	Z, r19
     90c:	31 97       	sbiw	r30, 0x01	; 1
     90e:	37 e1       	ldi	r19, 0x17	; 23
     910:	30 83       	st	Z, r19
     912:	31 97       	sbiw	r30, 0x01	; 1
     914:	38 e1       	ldi	r19, 0x18	; 24
     916:	30 83       	st	Z, r19
     918:	31 97       	sbiw	r30, 0x01	; 1
     91a:	39 e1       	ldi	r19, 0x19	; 25
     91c:	30 83       	st	Z, r19
     91e:	31 97       	sbiw	r30, 0x01	; 1
     920:	30 e2       	ldi	r19, 0x20	; 32
     922:	30 83       	st	Z, r19
     924:	31 97       	sbiw	r30, 0x01	; 1
     926:	31 e2       	ldi	r19, 0x21	; 33
     928:	30 83       	st	Z, r19
     92a:	31 97       	sbiw	r30, 0x01	; 1
     92c:	20 83       	st	Z, r18
     92e:	31 97       	sbiw	r30, 0x01	; 1
     930:	23 e2       	ldi	r18, 0x23	; 35
     932:	20 83       	st	Z, r18
     934:	31 97       	sbiw	r30, 0x01	; 1
     936:	40 83       	st	Z, r20
     938:	31 97       	sbiw	r30, 0x01	; 1
     93a:	50 83       	st	Z, r21
     93c:	31 97       	sbiw	r30, 0x01	; 1
     93e:	26 e2       	ldi	r18, 0x26	; 38
     940:	20 83       	st	Z, r18
     942:	31 97       	sbiw	r30, 0x01	; 1
     944:	27 e2       	ldi	r18, 0x27	; 39
     946:	20 83       	st	Z, r18
     948:	31 97       	sbiw	r30, 0x01	; 1
     94a:	28 e2       	ldi	r18, 0x28	; 40
     94c:	20 83       	st	Z, r18
     94e:	31 97       	sbiw	r30, 0x01	; 1
     950:	29 e2       	ldi	r18, 0x29	; 41
     952:	20 83       	st	Z, r18
     954:	31 97       	sbiw	r30, 0x01	; 1
     956:	20 e3       	ldi	r18, 0x30	; 48
     958:	20 83       	st	Z, r18
     95a:	31 97       	sbiw	r30, 0x01	; 1
     95c:	21 e3       	ldi	r18, 0x31	; 49
     95e:	20 83       	st	Z, r18
     960:	86 97       	sbiw	r24, 0x26	; 38
     962:	08 95       	ret

00000964 <xPortStartScheduler>:
     964:	89 df       	rcall	.-238    	; 0x878 <prvSetupTimerInterrupt>
     966:	a0 91 25 08 	lds	r26, 0x0825	; 0x800825 <pxCurrentTCB>
     96a:	b0 91 26 08 	lds	r27, 0x0826	; 0x800826 <pxCurrentTCB+0x1>
     96e:	cd 91       	ld	r28, X+
     970:	cd bf       	out	0x3d, r28	; 61
     972:	dd 91       	ld	r29, X+
     974:	de bf       	out	0x3e, r29	; 62
     976:	ff 91       	pop	r31
     978:	ef 91       	pop	r30
     97a:	df 91       	pop	r29
     97c:	cf 91       	pop	r28
     97e:	bf 91       	pop	r27
     980:	af 91       	pop	r26
     982:	9f 91       	pop	r25
     984:	8f 91       	pop	r24
     986:	7f 91       	pop	r23
     988:	6f 91       	pop	r22
     98a:	5f 91       	pop	r21
     98c:	4f 91       	pop	r20
     98e:	3f 91       	pop	r19
     990:	2f 91       	pop	r18
     992:	1f 91       	pop	r17
     994:	0f 91       	pop	r16
     996:	ff 90       	pop	r15
     998:	ef 90       	pop	r14
     99a:	df 90       	pop	r13
     99c:	cf 90       	pop	r12
     99e:	bf 90       	pop	r11
     9a0:	af 90       	pop	r10
     9a2:	9f 90       	pop	r9
     9a4:	8f 90       	pop	r8
     9a6:	7f 90       	pop	r7
     9a8:	6f 90       	pop	r6
     9aa:	5f 90       	pop	r5
     9ac:	4f 90       	pop	r4
     9ae:	3f 90       	pop	r3
     9b0:	2f 90       	pop	r2
     9b2:	1f 90       	pop	r1
     9b4:	0f 90       	pop	r0
     9b6:	0f be       	out	0x3f, r0	; 63
     9b8:	0f 90       	pop	r0
     9ba:	08 95       	ret
     9bc:	81 e0       	ldi	r24, 0x01	; 1
     9be:	08 95       	ret

000009c0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     9c0:	0f 92       	push	r0
     9c2:	0f b6       	in	r0, 0x3f	; 63
     9c4:	f8 94       	cli
     9c6:	0f 92       	push	r0
     9c8:	1f 92       	push	r1
     9ca:	11 24       	eor	r1, r1
     9cc:	2f 92       	push	r2
     9ce:	3f 92       	push	r3
     9d0:	4f 92       	push	r4
     9d2:	5f 92       	push	r5
     9d4:	6f 92       	push	r6
     9d6:	7f 92       	push	r7
     9d8:	8f 92       	push	r8
     9da:	9f 92       	push	r9
     9dc:	af 92       	push	r10
     9de:	bf 92       	push	r11
     9e0:	cf 92       	push	r12
     9e2:	df 92       	push	r13
     9e4:	ef 92       	push	r14
     9e6:	ff 92       	push	r15
     9e8:	0f 93       	push	r16
     9ea:	1f 93       	push	r17
     9ec:	2f 93       	push	r18
     9ee:	3f 93       	push	r19
     9f0:	4f 93       	push	r20
     9f2:	5f 93       	push	r21
     9f4:	6f 93       	push	r22
     9f6:	7f 93       	push	r23
     9f8:	8f 93       	push	r24
     9fa:	9f 93       	push	r25
     9fc:	af 93       	push	r26
     9fe:	bf 93       	push	r27
     a00:	cf 93       	push	r28
     a02:	df 93       	push	r29
     a04:	ef 93       	push	r30
     a06:	ff 93       	push	r31
     a08:	a0 91 25 08 	lds	r26, 0x0825	; 0x800825 <pxCurrentTCB>
     a0c:	b0 91 26 08 	lds	r27, 0x0826	; 0x800826 <pxCurrentTCB+0x1>
     a10:	0d b6       	in	r0, 0x3d	; 61
     a12:	0d 92       	st	X+, r0
     a14:	0e b6       	in	r0, 0x3e	; 62
	vTaskSwitchContext();
     a16:	0d 92       	st	X+, r0
	portRESTORE_CONTEXT();
     a18:	31 d6       	rcall	.+3170   	; 0x167c <vTaskSwitchContext>
     a1a:	a0 91 25 08 	lds	r26, 0x0825	; 0x800825 <pxCurrentTCB>
     a1e:	b0 91 26 08 	lds	r27, 0x0826	; 0x800826 <pxCurrentTCB+0x1>
     a22:	cd 91       	ld	r28, X+
     a24:	cd bf       	out	0x3d, r28	; 61
     a26:	dd 91       	ld	r29, X+
     a28:	de bf       	out	0x3e, r29	; 62
     a2a:	ff 91       	pop	r31
     a2c:	ef 91       	pop	r30
     a2e:	df 91       	pop	r29
     a30:	cf 91       	pop	r28
     a32:	bf 91       	pop	r27
     a34:	af 91       	pop	r26
     a36:	9f 91       	pop	r25
     a38:	8f 91       	pop	r24
     a3a:	7f 91       	pop	r23
     a3c:	6f 91       	pop	r22
     a3e:	5f 91       	pop	r21
     a40:	4f 91       	pop	r20
     a42:	3f 91       	pop	r19
     a44:	2f 91       	pop	r18
     a46:	1f 91       	pop	r17
     a48:	0f 91       	pop	r16
     a4a:	ff 90       	pop	r15
     a4c:	ef 90       	pop	r14
     a4e:	df 90       	pop	r13
     a50:	cf 90       	pop	r12
     a52:	bf 90       	pop	r11
     a54:	af 90       	pop	r10
     a56:	9f 90       	pop	r9
     a58:	8f 90       	pop	r8
     a5a:	7f 90       	pop	r7
     a5c:	6f 90       	pop	r6
     a5e:	5f 90       	pop	r5
     a60:	4f 90       	pop	r4
     a62:	3f 90       	pop	r3
     a64:	2f 90       	pop	r2
     a66:	1f 90       	pop	r1
     a68:	0f 90       	pop	r0
     a6a:	0f be       	out	0x3f, r0	; 63

	asm volatile ( "ret" );
     a6c:	0f 90       	pop	r0
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
     a6e:	08 95       	ret

00000a70 <vPortYieldFromTick>:
     a70:	0f 92       	push	r0
     a72:	0f b6       	in	r0, 0x3f	; 63
     a74:	f8 94       	cli
     a76:	0f 92       	push	r0
     a78:	1f 92       	push	r1
     a7a:	11 24       	eor	r1, r1
     a7c:	2f 92       	push	r2
     a7e:	3f 92       	push	r3
     a80:	4f 92       	push	r4
     a82:	5f 92       	push	r5
     a84:	6f 92       	push	r6
     a86:	7f 92       	push	r7
     a88:	8f 92       	push	r8
     a8a:	9f 92       	push	r9
     a8c:	af 92       	push	r10
     a8e:	bf 92       	push	r11
     a90:	cf 92       	push	r12
     a92:	df 92       	push	r13
     a94:	ef 92       	push	r14
     a96:	ff 92       	push	r15
     a98:	0f 93       	push	r16
     a9a:	1f 93       	push	r17
     a9c:	2f 93       	push	r18
     a9e:	3f 93       	push	r19
     aa0:	4f 93       	push	r20
     aa2:	5f 93       	push	r21
     aa4:	6f 93       	push	r22
     aa6:	7f 93       	push	r23
     aa8:	8f 93       	push	r24
     aaa:	9f 93       	push	r25
     aac:	af 93       	push	r26
     aae:	bf 93       	push	r27
     ab0:	cf 93       	push	r28
     ab2:	df 93       	push	r29
     ab4:	ef 93       	push	r30
     ab6:	ff 93       	push	r31
     ab8:	a0 91 25 08 	lds	r26, 0x0825	; 0x800825 <pxCurrentTCB>
     abc:	b0 91 26 08 	lds	r27, 0x0826	; 0x800826 <pxCurrentTCB+0x1>
     ac0:	0d b6       	in	r0, 0x3d	; 61
     ac2:	0d 92       	st	X+, r0
     ac4:	0e b6       	in	r0, 0x3e	; 62
     ac6:	0d 92       	st	X+, r0
     ac8:	7a d4       	rcall	.+2292   	; 0x13be <xTaskIncrementTick>
     aca:	81 11       	cpse	r24, r1
     acc:	d7 d5       	rcall	.+2990   	; 0x167c <vTaskSwitchContext>
     ace:	a0 91 25 08 	lds	r26, 0x0825	; 0x800825 <pxCurrentTCB>
     ad2:	b0 91 26 08 	lds	r27, 0x0826	; 0x800826 <pxCurrentTCB+0x1>
     ad6:	cd 91       	ld	r28, X+
     ad8:	cd bf       	out	0x3d, r28	; 61
     ada:	dd 91       	ld	r29, X+
     adc:	de bf       	out	0x3e, r29	; 62
     ade:	ff 91       	pop	r31
     ae0:	ef 91       	pop	r30
     ae2:	df 91       	pop	r29
     ae4:	cf 91       	pop	r28
     ae6:	bf 91       	pop	r27
     ae8:	af 91       	pop	r26
     aea:	9f 91       	pop	r25
     aec:	8f 91       	pop	r24
     aee:	7f 91       	pop	r23
     af0:	6f 91       	pop	r22
     af2:	5f 91       	pop	r21
     af4:	4f 91       	pop	r20
     af6:	3f 91       	pop	r19
     af8:	2f 91       	pop	r18
     afa:	1f 91       	pop	r17
     afc:	0f 91       	pop	r16
     afe:	ff 90       	pop	r15
     b00:	ef 90       	pop	r14
     b02:	df 90       	pop	r13
     b04:	cf 90       	pop	r12
     b06:	bf 90       	pop	r11
     b08:	af 90       	pop	r10
     b0a:	9f 90       	pop	r9
     b0c:	8f 90       	pop	r8
     b0e:	7f 90       	pop	r7
     b10:	6f 90       	pop	r6
     b12:	5f 90       	pop	r5
     b14:	4f 90       	pop	r4
     b16:	3f 90       	pop	r3
     b18:	2f 90       	pop	r2
     b1a:	1f 90       	pop	r1
     b1c:	0f 90       	pop	r0
     b1e:	0f be       	out	0x3f, r0	; 63
     b20:	0f 90       	pop	r0
     b22:	08 95       	ret

00000b24 <__vector_7>:
     b24:	a5 df       	rcall	.-182    	; 0xa70 <vPortYieldFromTick>
     b26:	18 95       	reti

00000b28 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     b28:	cf 93       	push	r28
     b2a:	df 93       	push	r29
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     b2c:	ec 01       	movw	r28, r24
	{
		if( pucAlignedHeap == NULL )
     b2e:	37 d4       	rcall	.+2158   	; 0x139e <vTaskSuspendAll>
     b30:	80 91 bf 00 	lds	r24, 0x00BF	; 0x8000bf <pucAlignedHeap.2067>
     b34:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <pucAlignedHeap.2067+0x1>
     b38:	89 2b       	or	r24, r25
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     b3a:	31 f4       	brne	.+12     	; 0xb48 <pvPortMalloc+0x20>
     b3c:	84 ec       	ldi	r24, 0xC4	; 196
     b3e:	90 e0       	ldi	r25, 0x00	; 0
     b40:	90 93 c0 00 	sts	0x00C0, r25	; 0x8000c0 <pucAlignedHeap.2067+0x1>
     b44:	80 93 bf 00 	sts	0x00BF, r24	; 0x8000bf <pucAlignedHeap.2067>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     b48:	20 91 c1 00 	lds	r18, 0x00C1	; 0x8000c1 <xNextFreeByte>
     b4c:	30 91 c2 00 	lds	r19, 0x00C2	; 0x8000c2 <xNextFreeByte+0x1>
     b50:	c9 01       	movw	r24, r18
     b52:	8c 0f       	add	r24, r28
     b54:	9d 1f       	adc	r25, r29
     b56:	87 30       	cpi	r24, 0x07	; 7
     b58:	47 e0       	ldi	r20, 0x07	; 7
     b5a:	94 07       	cpc	r25, r20
     b5c:	70 f4       	brcc	.+28     	; 0xb7a <pvPortMalloc+0x52>
     b5e:	28 17       	cp	r18, r24
     b60:	39 07       	cpc	r19, r25
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     b62:	70 f4       	brcc	.+28     	; 0xb80 <pvPortMalloc+0x58>
     b64:	c0 91 bf 00 	lds	r28, 0x00BF	; 0x8000bf <pucAlignedHeap.2067>
     b68:	d0 91 c0 00 	lds	r29, 0x00C0	; 0x8000c0 <pucAlignedHeap.2067+0x1>
     b6c:	c2 0f       	add	r28, r18
			xNextFreeByte += xWantedSize;
     b6e:	d3 1f       	adc	r29, r19
     b70:	90 93 c2 00 	sts	0x00C2, r25	; 0x8000c2 <xNextFreeByte+0x1>
     b74:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <xNextFreeByte>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     b78:	05 c0       	rjmp	.+10     	; 0xb84 <pvPortMalloc+0x5c>
     b7a:	c0 e0       	ldi	r28, 0x00	; 0
     b7c:	d0 e0       	ldi	r29, 0x00	; 0
     b7e:	02 c0       	rjmp	.+4      	; 0xb84 <pvPortMalloc+0x5c>
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     b80:	c0 e0       	ldi	r28, 0x00	; 0
     b82:	d0 e0       	ldi	r29, 0x00	; 0
		}
	}
	#endif

	return pvReturn;
}
     b84:	d2 d4       	rcall	.+2468   	; 0x152a <xTaskResumeAll>
     b86:	ce 01       	movw	r24, r28
     b88:	df 91       	pop	r29
     b8a:	cf 91       	pop	r28
     b8c:	08 95       	ret

00000b8e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     b8e:	08 95       	ret

00000b90 <prvIsQueueEmpty>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     b90:	0f b6       	in	r0, 0x3f	; 63
     b92:	f8 94       	cli
     b94:	0f 92       	push	r0
     b96:	fc 01       	movw	r30, r24
     b98:	82 8d       	ldd	r24, Z+26	; 0x1a
     b9a:	81 11       	cpse	r24, r1
     b9c:	02 c0       	rjmp	.+4      	; 0xba2 <prvIsQueueEmpty+0x12>
     b9e:	81 e0       	ldi	r24, 0x01	; 1
     ba0:	01 c0       	rjmp	.+2      	; 0xba4 <prvIsQueueEmpty+0x14>
     ba2:	80 e0       	ldi	r24, 0x00	; 0
     ba4:	0f 90       	pop	r0
     ba6:	0f be       	out	0x3f, r0	; 63
     ba8:	08 95       	ret

00000baa <prvIsQueueFull>:
     baa:	0f b6       	in	r0, 0x3f	; 63
     bac:	f8 94       	cli
     bae:	0f 92       	push	r0
     bb0:	fc 01       	movw	r30, r24
     bb2:	22 8d       	ldd	r18, Z+26	; 0x1a
     bb4:	83 8d       	ldd	r24, Z+27	; 0x1b
     bb6:	28 13       	cpse	r18, r24
     bb8:	02 c0       	rjmp	.+4      	; 0xbbe <prvIsQueueFull+0x14>
     bba:	81 e0       	ldi	r24, 0x01	; 1
     bbc:	01 c0       	rjmp	.+2      	; 0xbc0 <prvIsQueueFull+0x16>
     bbe:	80 e0       	ldi	r24, 0x00	; 0
     bc0:	0f 90       	pop	r0
     bc2:	0f be       	out	0x3f, r0	; 63
     bc4:	08 95       	ret

00000bc6 <prvCopyDataToQueue>:
     bc6:	0f 93       	push	r16
     bc8:	1f 93       	push	r17
     bca:	cf 93       	push	r28
     bcc:	df 93       	push	r29
     bce:	ec 01       	movw	r28, r24
     bd0:	04 2f       	mov	r16, r20
     bd2:	1a 8d       	ldd	r17, Y+26	; 0x1a
     bd4:	4c 8d       	ldd	r20, Y+28	; 0x1c
     bd6:	44 23       	and	r20, r20
     bd8:	a9 f1       	breq	.+106    	; 0xc44 <prvCopyDataToQueue+0x7e>
     bda:	01 11       	cpse	r16, r1
     bdc:	15 c0       	rjmp	.+42     	; 0xc08 <prvCopyDataToQueue+0x42>
     bde:	50 e0       	ldi	r21, 0x00	; 0
     be0:	8c 81       	ldd	r24, Y+4	; 0x04
     be2:	9d 81       	ldd	r25, Y+5	; 0x05
     be4:	0f d7       	rcall	.+3614   	; 0x1a04 <memcpy>
     be6:	2c 8d       	ldd	r18, Y+28	; 0x1c
     be8:	8c 81       	ldd	r24, Y+4	; 0x04
     bea:	9d 81       	ldd	r25, Y+5	; 0x05
     bec:	82 0f       	add	r24, r18
     bee:	91 1d       	adc	r25, r1
     bf0:	9d 83       	std	Y+5, r25	; 0x05
     bf2:	8c 83       	std	Y+4, r24	; 0x04
     bf4:	2a 81       	ldd	r18, Y+2	; 0x02
     bf6:	3b 81       	ldd	r19, Y+3	; 0x03
     bf8:	82 17       	cp	r24, r18
     bfa:	93 07       	cpc	r25, r19
     bfc:	18 f1       	brcs	.+70     	; 0xc44 <prvCopyDataToQueue+0x7e>
     bfe:	88 81       	ld	r24, Y
     c00:	99 81       	ldd	r25, Y+1	; 0x01
     c02:	9d 83       	std	Y+5, r25	; 0x05
     c04:	8c 83       	std	Y+4, r24	; 0x04
     c06:	1e c0       	rjmp	.+60     	; 0xc44 <prvCopyDataToQueue+0x7e>
     c08:	50 e0       	ldi	r21, 0x00	; 0
     c0a:	8e 81       	ldd	r24, Y+6	; 0x06
     c0c:	9f 81       	ldd	r25, Y+7	; 0x07
     c0e:	fa d6       	rcall	.+3572   	; 0x1a04 <memcpy>
     c10:	8c 8d       	ldd	r24, Y+28	; 0x1c
     c12:	90 e0       	ldi	r25, 0x00	; 0
     c14:	91 95       	neg	r25
     c16:	81 95       	neg	r24
     c18:	91 09       	sbc	r25, r1
     c1a:	2e 81       	ldd	r18, Y+6	; 0x06
     c1c:	3f 81       	ldd	r19, Y+7	; 0x07
     c1e:	28 0f       	add	r18, r24
     c20:	39 1f       	adc	r19, r25
     c22:	3f 83       	std	Y+7, r19	; 0x07
     c24:	2e 83       	std	Y+6, r18	; 0x06
     c26:	48 81       	ld	r20, Y
     c28:	59 81       	ldd	r21, Y+1	; 0x01
     c2a:	24 17       	cp	r18, r20
     c2c:	35 07       	cpc	r19, r21
     c2e:	30 f4       	brcc	.+12     	; 0xc3c <prvCopyDataToQueue+0x76>
     c30:	2a 81       	ldd	r18, Y+2	; 0x02
     c32:	3b 81       	ldd	r19, Y+3	; 0x03
     c34:	82 0f       	add	r24, r18
     c36:	93 1f       	adc	r25, r19
     c38:	9f 83       	std	Y+7, r25	; 0x07
     c3a:	8e 83       	std	Y+6, r24	; 0x06
     c3c:	02 30       	cpi	r16, 0x02	; 2
     c3e:	11 f4       	brne	.+4      	; 0xc44 <prvCopyDataToQueue+0x7e>
     c40:	11 11       	cpse	r17, r1
     c42:	11 50       	subi	r17, 0x01	; 1
     c44:	1f 5f       	subi	r17, 0xFF	; 255
     c46:	1a 8f       	std	Y+26, r17	; 0x1a
     c48:	80 e0       	ldi	r24, 0x00	; 0
     c4a:	df 91       	pop	r29
     c4c:	cf 91       	pop	r28
     c4e:	1f 91       	pop	r17
     c50:	0f 91       	pop	r16
     c52:	08 95       	ret

00000c54 <prvCopyDataFromQueue>:
     c54:	fc 01       	movw	r30, r24
     c56:	44 8d       	ldd	r20, Z+28	; 0x1c
     c58:	44 23       	and	r20, r20
     c5a:	a1 f0       	breq	.+40     	; 0xc84 <prvCopyDataFromQueue+0x30>
     c5c:	50 e0       	ldi	r21, 0x00	; 0
     c5e:	26 81       	ldd	r18, Z+6	; 0x06
     c60:	37 81       	ldd	r19, Z+7	; 0x07
     c62:	24 0f       	add	r18, r20
     c64:	35 1f       	adc	r19, r21
     c66:	37 83       	std	Z+7, r19	; 0x07
     c68:	26 83       	std	Z+6, r18	; 0x06
     c6a:	82 81       	ldd	r24, Z+2	; 0x02
     c6c:	93 81       	ldd	r25, Z+3	; 0x03
     c6e:	28 17       	cp	r18, r24
     c70:	39 07       	cpc	r19, r25
     c72:	20 f0       	brcs	.+8      	; 0xc7c <prvCopyDataFromQueue+0x28>
     c74:	80 81       	ld	r24, Z
     c76:	91 81       	ldd	r25, Z+1	; 0x01
     c78:	97 83       	std	Z+7, r25	; 0x07
     c7a:	86 83       	std	Z+6, r24	; 0x06
     c7c:	cb 01       	movw	r24, r22
     c7e:	66 81       	ldd	r22, Z+6	; 0x06
     c80:	77 81       	ldd	r23, Z+7	; 0x07
     c82:	c0 c6       	rjmp	.+3456   	; 0x1a04 <memcpy>
     c84:	08 95       	ret

00000c86 <prvUnlockQueue>:
     c86:	1f 93       	push	r17
     c88:	cf 93       	push	r28
     c8a:	df 93       	push	r29
     c8c:	ec 01       	movw	r28, r24
     c8e:	0f b6       	in	r0, 0x3f	; 63
     c90:	f8 94       	cli
     c92:	0f 92       	push	r0
     c94:	1e 8d       	ldd	r17, Y+30	; 0x1e
     c96:	09 c0       	rjmp	.+18     	; 0xcaa <prvUnlockQueue+0x24>
     c98:	89 89       	ldd	r24, Y+17	; 0x11
     c9a:	88 23       	and	r24, r24
     c9c:	41 f0       	breq	.+16     	; 0xcae <prvUnlockQueue+0x28>
     c9e:	ce 01       	movw	r24, r28
     ca0:	41 96       	adiw	r24, 0x11	; 17
     ca2:	50 d5       	rcall	.+2720   	; 0x1744 <xTaskRemoveFromEventList>
     ca4:	81 11       	cpse	r24, r1
     ca6:	d0 d5       	rcall	.+2976   	; 0x1848 <vTaskMissedYield>
     ca8:	11 50       	subi	r17, 0x01	; 1
     caa:	11 16       	cp	r1, r17
     cac:	ac f3       	brlt	.-22     	; 0xc98 <prvUnlockQueue+0x12>
     cae:	8f ef       	ldi	r24, 0xFF	; 255
     cb0:	8e 8f       	std	Y+30, r24	; 0x1e
     cb2:	0f 90       	pop	r0
     cb4:	0f be       	out	0x3f, r0	; 63
     cb6:	0f b6       	in	r0, 0x3f	; 63
     cb8:	f8 94       	cli
     cba:	0f 92       	push	r0
     cbc:	1d 8d       	ldd	r17, Y+29	; 0x1d
     cbe:	09 c0       	rjmp	.+18     	; 0xcd2 <prvUnlockQueue+0x4c>
     cc0:	88 85       	ldd	r24, Y+8	; 0x08
     cc2:	88 23       	and	r24, r24
     cc4:	41 f0       	breq	.+16     	; 0xcd6 <prvUnlockQueue+0x50>
     cc6:	ce 01       	movw	r24, r28
     cc8:	08 96       	adiw	r24, 0x08	; 8
     cca:	3c d5       	rcall	.+2680   	; 0x1744 <xTaskRemoveFromEventList>
     ccc:	81 11       	cpse	r24, r1
     cce:	bc d5       	rcall	.+2936   	; 0x1848 <vTaskMissedYield>
     cd0:	11 50       	subi	r17, 0x01	; 1
     cd2:	11 16       	cp	r1, r17
     cd4:	ac f3       	brlt	.-22     	; 0xcc0 <prvUnlockQueue+0x3a>
     cd6:	8f ef       	ldi	r24, 0xFF	; 255
     cd8:	8d 8f       	std	Y+29, r24	; 0x1d
     cda:	0f 90       	pop	r0
     cdc:	0f be       	out	0x3f, r0	; 63
     cde:	df 91       	pop	r29
     ce0:	cf 91       	pop	r28
     ce2:	1f 91       	pop	r17
     ce4:	08 95       	ret

00000ce6 <xQueueGenericReset>:
     ce6:	cf 93       	push	r28
     ce8:	df 93       	push	r29
     cea:	ec 01       	movw	r28, r24
     cec:	0f b6       	in	r0, 0x3f	; 63
     cee:	f8 94       	cli
     cf0:	0f 92       	push	r0
     cf2:	e8 81       	ld	r30, Y
     cf4:	f9 81       	ldd	r31, Y+1	; 0x01
     cf6:	8b 8d       	ldd	r24, Y+27	; 0x1b
     cf8:	90 e0       	ldi	r25, 0x00	; 0
     cfa:	2c 8d       	ldd	r18, Y+28	; 0x1c
     cfc:	30 e0       	ldi	r19, 0x00	; 0
     cfe:	82 9f       	mul	r24, r18
     d00:	a0 01       	movw	r20, r0
     d02:	83 9f       	mul	r24, r19
     d04:	50 0d       	add	r21, r0
     d06:	92 9f       	mul	r25, r18
     d08:	50 0d       	add	r21, r0
     d0a:	11 24       	eor	r1, r1
     d0c:	4e 0f       	add	r20, r30
     d0e:	5f 1f       	adc	r21, r31
     d10:	5b 83       	std	Y+3, r21	; 0x03
     d12:	4a 83       	std	Y+2, r20	; 0x02
     d14:	1a 8e       	std	Y+26, r1	; 0x1a
     d16:	fd 83       	std	Y+5, r31	; 0x05
     d18:	ec 83       	std	Y+4, r30	; 0x04
     d1a:	01 97       	sbiw	r24, 0x01	; 1
     d1c:	28 9f       	mul	r18, r24
     d1e:	a0 01       	movw	r20, r0
     d20:	29 9f       	mul	r18, r25
     d22:	50 0d       	add	r21, r0
     d24:	38 9f       	mul	r19, r24
     d26:	50 0d       	add	r21, r0
     d28:	11 24       	eor	r1, r1
     d2a:	cf 01       	movw	r24, r30
     d2c:	84 0f       	add	r24, r20
     d2e:	95 1f       	adc	r25, r21
     d30:	9f 83       	std	Y+7, r25	; 0x07
     d32:	8e 83       	std	Y+6, r24	; 0x06
     d34:	8f ef       	ldi	r24, 0xFF	; 255
     d36:	8d 8f       	std	Y+29, r24	; 0x1d
     d38:	8e 8f       	std	Y+30, r24	; 0x1e
     d3a:	61 11       	cpse	r22, r1
     d3c:	0a c0       	rjmp	.+20     	; 0xd52 <xQueueGenericReset+0x6c>
     d3e:	88 85       	ldd	r24, Y+8	; 0x08
     d40:	88 23       	and	r24, r24
     d42:	69 f0       	breq	.+26     	; 0xd5e <xQueueGenericReset+0x78>
     d44:	ce 01       	movw	r24, r28
     d46:	08 96       	adiw	r24, 0x08	; 8
     d48:	fd d4       	rcall	.+2554   	; 0x1744 <xTaskRemoveFromEventList>
     d4a:	88 23       	and	r24, r24
     d4c:	41 f0       	breq	.+16     	; 0xd5e <xQueueGenericReset+0x78>
     d4e:	38 de       	rcall	.-912    	; 0x9c0 <vPortYield>
     d50:	06 c0       	rjmp	.+12     	; 0xd5e <xQueueGenericReset+0x78>
     d52:	ce 01       	movw	r24, r28
     d54:	08 96       	adiw	r24, 0x08	; 8
     d56:	06 dd       	rcall	.-1524   	; 0x764 <vListInitialise>
     d58:	ce 01       	movw	r24, r28
     d5a:	41 96       	adiw	r24, 0x11	; 17
     d5c:	03 dd       	rcall	.-1530   	; 0x764 <vListInitialise>
     d5e:	0f 90       	pop	r0
     d60:	0f be       	out	0x3f, r0	; 63
     d62:	81 e0       	ldi	r24, 0x01	; 1
     d64:	df 91       	pop	r29
     d66:	cf 91       	pop	r28
     d68:	08 95       	ret

00000d6a <prvInitialiseNewQueue>:
     d6a:	0f 93       	push	r16
     d6c:	1f 93       	push	r17
     d6e:	f8 01       	movw	r30, r16
     d70:	61 11       	cpse	r22, r1
     d72:	03 c0       	rjmp	.+6      	; 0xd7a <prvInitialiseNewQueue+0x10>
     d74:	11 83       	std	Z+1, r17	; 0x01
     d76:	00 83       	st	Z, r16
     d78:	02 c0       	rjmp	.+4      	; 0xd7e <prvInitialiseNewQueue+0x14>
     d7a:	51 83       	std	Z+1, r21	; 0x01
     d7c:	40 83       	st	Z, r20
     d7e:	83 8f       	std	Z+27, r24	; 0x1b
     d80:	64 8f       	std	Z+28, r22	; 0x1c
     d82:	61 e0       	ldi	r22, 0x01	; 1
     d84:	cf 01       	movw	r24, r30
     d86:	af df       	rcall	.-162    	; 0xce6 <xQueueGenericReset>
     d88:	1f 91       	pop	r17
     d8a:	0f 91       	pop	r16
     d8c:	08 95       	ret

00000d8e <xQueueGenericCreate>:
     d8e:	df 92       	push	r13
     d90:	ef 92       	push	r14
     d92:	ff 92       	push	r15
     d94:	0f 93       	push	r16
     d96:	1f 93       	push	r17
     d98:	cf 93       	push	r28
     d9a:	df 93       	push	r29
     d9c:	e8 2e       	mov	r14, r24
     d9e:	f6 2e       	mov	r15, r22
     da0:	d4 2e       	mov	r13, r20
     da2:	66 23       	and	r22, r22
     da4:	21 f0       	breq	.+8      	; 0xdae <xQueueGenericCreate+0x20>
     da6:	86 9f       	mul	r24, r22
     da8:	c0 01       	movw	r24, r0
     daa:	11 24       	eor	r1, r1
     dac:	02 c0       	rjmp	.+4      	; 0xdb2 <xQueueGenericCreate+0x24>
     dae:	80 e0       	ldi	r24, 0x00	; 0
     db0:	90 e0       	ldi	r25, 0x00	; 0
     db2:	4f 96       	adiw	r24, 0x1f	; 31
     db4:	b9 de       	rcall	.-654    	; 0xb28 <pvPortMalloc>
     db6:	ec 01       	movw	r28, r24
     db8:	00 97       	sbiw	r24, 0x00	; 0
     dba:	41 f0       	breq	.+16     	; 0xdcc <xQueueGenericCreate+0x3e>
     dbc:	8c 01       	movw	r16, r24
     dbe:	2d 2d       	mov	r18, r13
     dc0:	ac 01       	movw	r20, r24
     dc2:	41 5e       	subi	r20, 0xE1	; 225
     dc4:	5f 4f       	sbci	r21, 0xFF	; 255
     dc6:	6f 2d       	mov	r22, r15
     dc8:	8e 2d       	mov	r24, r14
     dca:	cf df       	rcall	.-98     	; 0xd6a <prvInitialiseNewQueue>
     dcc:	ce 01       	movw	r24, r28
     dce:	df 91       	pop	r29
     dd0:	cf 91       	pop	r28
     dd2:	1f 91       	pop	r17
     dd4:	0f 91       	pop	r16
     dd6:	ff 90       	pop	r15
     dd8:	ef 90       	pop	r14
     dda:	df 90       	pop	r13
     ddc:	08 95       	ret

00000dde <xQueueGenericSend>:
     dde:	cf 92       	push	r12
     de0:	df 92       	push	r13
     de2:	ef 92       	push	r14
     de4:	ff 92       	push	r15
     de6:	0f 93       	push	r16
     de8:	1f 93       	push	r17
     dea:	cf 93       	push	r28
     dec:	df 93       	push	r29
     dee:	00 d0       	rcall	.+0      	; 0xdf0 <xQueueGenericSend+0x12>
     df0:	00 d0       	rcall	.+0      	; 0xdf2 <xQueueGenericSend+0x14>
     df2:	1f 92       	push	r1
     df4:	cd b7       	in	r28, 0x3d	; 61
     df6:	de b7       	in	r29, 0x3e	; 62
     df8:	8c 01       	movw	r16, r24
     dfa:	7b 01       	movw	r14, r22
     dfc:	5d 83       	std	Y+5, r21	; 0x05
     dfe:	4c 83       	std	Y+4, r20	; 0x04
     e00:	c2 2e       	mov	r12, r18
     e02:	d1 2c       	mov	r13, r1
     e04:	0f b6       	in	r0, 0x3f	; 63
     e06:	f8 94       	cli
     e08:	0f 92       	push	r0
     e0a:	f8 01       	movw	r30, r16
     e0c:	92 8d       	ldd	r25, Z+26	; 0x1a
     e0e:	83 8d       	ldd	r24, Z+27	; 0x1b
     e10:	98 17       	cp	r25, r24
     e12:	18 f0       	brcs	.+6      	; 0xe1a <xQueueGenericSend+0x3c>
     e14:	f2 e0       	ldi	r31, 0x02	; 2
     e16:	cf 12       	cpse	r12, r31
     e18:	15 c0       	rjmp	.+42     	; 0xe44 <xQueueGenericSend+0x66>
     e1a:	4c 2d       	mov	r20, r12
     e1c:	b7 01       	movw	r22, r14
     e1e:	c8 01       	movw	r24, r16
     e20:	d2 de       	rcall	.-604    	; 0xbc6 <prvCopyDataToQueue>
     e22:	f8 01       	movw	r30, r16
     e24:	91 89       	ldd	r25, Z+17	; 0x11
     e26:	99 23       	and	r25, r25
     e28:	39 f0       	breq	.+14     	; 0xe38 <xQueueGenericSend+0x5a>
     e2a:	c8 01       	movw	r24, r16
     e2c:	41 96       	adiw	r24, 0x11	; 17
     e2e:	8a d4       	rcall	.+2324   	; 0x1744 <xTaskRemoveFromEventList>
     e30:	88 23       	and	r24, r24
     e32:	21 f0       	breq	.+8      	; 0xe3c <xQueueGenericSend+0x5e>
     e34:	c5 dd       	rcall	.-1142   	; 0x9c0 <vPortYield>
     e36:	02 c0       	rjmp	.+4      	; 0xe3c <xQueueGenericSend+0x5e>
     e38:	81 11       	cpse	r24, r1
     e3a:	c2 dd       	rcall	.-1148   	; 0x9c0 <vPortYield>
     e3c:	0f 90       	pop	r0
     e3e:	0f be       	out	0x3f, r0	; 63
     e40:	81 e0       	ldi	r24, 0x01	; 1
     e42:	41 c0       	rjmp	.+130    	; 0xec6 <xQueueGenericSend+0xe8>
     e44:	8c 81       	ldd	r24, Y+4	; 0x04
     e46:	9d 81       	ldd	r25, Y+5	; 0x05
     e48:	89 2b       	or	r24, r25
     e4a:	21 f4       	brne	.+8      	; 0xe54 <xQueueGenericSend+0x76>
     e4c:	0f 90       	pop	r0
     e4e:	0f be       	out	0x3f, r0	; 63
     e50:	80 e0       	ldi	r24, 0x00	; 0
     e52:	39 c0       	rjmp	.+114    	; 0xec6 <xQueueGenericSend+0xe8>
     e54:	d1 10       	cpse	r13, r1
     e56:	05 c0       	rjmp	.+10     	; 0xe62 <xQueueGenericSend+0x84>
     e58:	ce 01       	movw	r24, r28
     e5a:	01 96       	adiw	r24, 0x01	; 1
     e5c:	b9 d4       	rcall	.+2418   	; 0x17d0 <vTaskSetTimeOutState>
     e5e:	dd 24       	eor	r13, r13
     e60:	d3 94       	inc	r13
     e62:	0f 90       	pop	r0
     e64:	0f be       	out	0x3f, r0	; 63
     e66:	9b d2       	rcall	.+1334   	; 0x139e <vTaskSuspendAll>
     e68:	0f b6       	in	r0, 0x3f	; 63
     e6a:	f8 94       	cli
     e6c:	0f 92       	push	r0
     e6e:	f8 01       	movw	r30, r16
     e70:	85 8d       	ldd	r24, Z+29	; 0x1d
     e72:	8f 3f       	cpi	r24, 0xFF	; 255
     e74:	09 f4       	brne	.+2      	; 0xe78 <xQueueGenericSend+0x9a>
     e76:	15 8e       	std	Z+29, r1	; 0x1d
     e78:	f8 01       	movw	r30, r16
     e7a:	86 8d       	ldd	r24, Z+30	; 0x1e
     e7c:	8f 3f       	cpi	r24, 0xFF	; 255
     e7e:	09 f4       	brne	.+2      	; 0xe82 <xQueueGenericSend+0xa4>
     e80:	16 8e       	std	Z+30, r1	; 0x1e
     e82:	0f 90       	pop	r0
     e84:	0f be       	out	0x3f, r0	; 63
     e86:	be 01       	movw	r22, r28
     e88:	6c 5f       	subi	r22, 0xFC	; 252
     e8a:	7f 4f       	sbci	r23, 0xFF	; 255
     e8c:	ce 01       	movw	r24, r28
     e8e:	01 96       	adiw	r24, 0x01	; 1
     e90:	aa d4       	rcall	.+2388   	; 0x17e6 <xTaskCheckForTimeOut>
     e92:	81 11       	cpse	r24, r1
     e94:	14 c0       	rjmp	.+40     	; 0xebe <xQueueGenericSend+0xe0>
     e96:	c8 01       	movw	r24, r16
     e98:	88 de       	rcall	.-752    	; 0xbaa <prvIsQueueFull>
     e9a:	88 23       	and	r24, r24
     e9c:	61 f0       	breq	.+24     	; 0xeb6 <xQueueGenericSend+0xd8>
     e9e:	6c 81       	ldd	r22, Y+4	; 0x04
     ea0:	7d 81       	ldd	r23, Y+5	; 0x05
     ea2:	c8 01       	movw	r24, r16
     ea4:	08 96       	adiw	r24, 0x08	; 8
     ea6:	3e d4       	rcall	.+2172   	; 0x1724 <vTaskPlaceOnEventList>
     ea8:	c8 01       	movw	r24, r16
     eaa:	ed de       	rcall	.-550    	; 0xc86 <prvUnlockQueue>
     eac:	3e d3       	rcall	.+1660   	; 0x152a <xTaskResumeAll>
     eae:	81 11       	cpse	r24, r1
     eb0:	a9 cf       	rjmp	.-174    	; 0xe04 <xQueueGenericSend+0x26>
     eb2:	86 dd       	rcall	.-1268   	; 0x9c0 <vPortYield>
     eb4:	a7 cf       	rjmp	.-178    	; 0xe04 <xQueueGenericSend+0x26>
     eb6:	c8 01       	movw	r24, r16
     eb8:	e6 de       	rcall	.-564    	; 0xc86 <prvUnlockQueue>
     eba:	37 d3       	rcall	.+1646   	; 0x152a <xTaskResumeAll>
     ebc:	a3 cf       	rjmp	.-186    	; 0xe04 <xQueueGenericSend+0x26>
     ebe:	c8 01       	movw	r24, r16
     ec0:	e2 de       	rcall	.-572    	; 0xc86 <prvUnlockQueue>
     ec2:	33 d3       	rcall	.+1638   	; 0x152a <xTaskResumeAll>
     ec4:	80 e0       	ldi	r24, 0x00	; 0
     ec6:	0f 90       	pop	r0
     ec8:	0f 90       	pop	r0
     eca:	0f 90       	pop	r0
     ecc:	0f 90       	pop	r0
     ece:	0f 90       	pop	r0
     ed0:	df 91       	pop	r29
     ed2:	cf 91       	pop	r28
     ed4:	1f 91       	pop	r17
     ed6:	0f 91       	pop	r16
     ed8:	ff 90       	pop	r15
     eda:	ef 90       	pop	r14
     edc:	df 90       	pop	r13
     ede:	cf 90       	pop	r12
     ee0:	08 95       	ret

00000ee2 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     ee2:	8f 92       	push	r8
     ee4:	9f 92       	push	r9
     ee6:	bf 92       	push	r11
     ee8:	cf 92       	push	r12
     eea:	df 92       	push	r13
     eec:	ef 92       	push	r14
     eee:	ff 92       	push	r15
     ef0:	0f 93       	push	r16
     ef2:	1f 93       	push	r17
     ef4:	cf 93       	push	r28
     ef6:	df 93       	push	r29
     ef8:	00 d0       	rcall	.+0      	; 0xefa <xQueueGenericReceive+0x18>
     efa:	00 d0       	rcall	.+0      	; 0xefc <xQueueGenericReceive+0x1a>
     efc:	1f 92       	push	r1
     efe:	cd b7       	in	r28, 0x3d	; 61
     f00:	de b7       	in	r29, 0x3e	; 62
     f02:	8c 01       	movw	r16, r24
     f04:	6b 01       	movw	r12, r22
     f06:	5d 83       	std	Y+5, r21	; 0x05
     f08:	4c 83       	std	Y+4, r20	; 0x04
     f0a:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
     f0c:	e1 2c       	mov	r14, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     f0e:	0f b6       	in	r0, 0x3f	; 63
     f10:	f8 94       	cli
     f12:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     f14:	f8 01       	movw	r30, r16
     f16:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     f18:	ff 20       	and	r15, r15
     f1a:	19 f1       	breq	.+70     	; 0xf62 <xQueueGenericReceive+0x80>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     f1c:	86 80       	ldd	r8, Z+6	; 0x06
     f1e:	97 80       	ldd	r9, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     f20:	b6 01       	movw	r22, r12
     f22:	c8 01       	movw	r24, r16
     f24:	97 de       	rcall	.-722    	; 0xc54 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     f26:	b1 10       	cpse	r11, r1
     f28:	0d c0       	rjmp	.+26     	; 0xf44 <xQueueGenericReceive+0x62>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
     f2a:	fa 94       	dec	r15
     f2c:	f8 01       	movw	r30, r16
     f2e:	f2 8e       	std	Z+26, r15	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     f30:	80 85       	ldd	r24, Z+8	; 0x08
     f32:	88 23       	and	r24, r24
     f34:	91 f0       	breq	.+36     	; 0xf5a <xQueueGenericReceive+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     f36:	c8 01       	movw	r24, r16
     f38:	08 96       	adiw	r24, 0x08	; 8
     f3a:	04 d4       	rcall	.+2056   	; 0x1744 <xTaskRemoveFromEventList>
     f3c:	88 23       	and	r24, r24
						{
							queueYIELD_IF_USING_PREEMPTION();
     f3e:	69 f0       	breq	.+26     	; 0xf5a <xQueueGenericReceive+0x78>
     f40:	3f dd       	rcall	.-1410   	; 0x9c0 <vPortYield>
     f42:	0b c0       	rjmp	.+22     	; 0xf5a <xQueueGenericReceive+0x78>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     f44:	f8 01       	movw	r30, r16
     f46:	97 82       	std	Z+7, r9	; 0x07
     f48:	86 82       	std	Z+6, r8	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     f4a:	81 89       	ldd	r24, Z+17	; 0x11
     f4c:	88 23       	and	r24, r24
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     f4e:	29 f0       	breq	.+10     	; 0xf5a <xQueueGenericReceive+0x78>
     f50:	c8 01       	movw	r24, r16
     f52:	41 96       	adiw	r24, 0x11	; 17
     f54:	f7 d3       	rcall	.+2030   	; 0x1744 <xTaskRemoveFromEventList>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     f56:	81 11       	cpse	r24, r1
     f58:	33 dd       	rcall	.-1434   	; 0x9c0 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     f5a:	0f 90       	pop	r0
     f5c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     f5e:	81 e0       	ldi	r24, 0x01	; 1
     f60:	46 c0       	rjmp	.+140    	; 0xfee <xQueueGenericReceive+0x10c>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     f62:	8c 81       	ldd	r24, Y+4	; 0x04
     f64:	9d 81       	ldd	r25, Y+5	; 0x05
     f66:	89 2b       	or	r24, r25
     f68:	21 f4       	brne	.+8      	; 0xf72 <xQueueGenericReceive+0x90>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     f6a:	0f 90       	pop	r0
     f6c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     f6e:	80 e0       	ldi	r24, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
     f70:	3e c0       	rjmp	.+124    	; 0xfee <xQueueGenericReceive+0x10c>
     f72:	e1 10       	cpse	r14, r1
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     f74:	05 c0       	rjmp	.+10     	; 0xf80 <xQueueGenericReceive+0x9e>
     f76:	ce 01       	movw	r24, r28
     f78:	01 96       	adiw	r24, 0x01	; 1
					xEntryTimeSet = pdTRUE;
     f7a:	2a d4       	rcall	.+2132   	; 0x17d0 <vTaskSetTimeOutState>
     f7c:	ee 24       	eor	r14, r14
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     f7e:	e3 94       	inc	r14
     f80:	0f 90       	pop	r0

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     f82:	0f be       	out	0x3f, r0	; 63
     f84:	0c d2       	rcall	.+1048   	; 0x139e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     f86:	0f b6       	in	r0, 0x3f	; 63
     f88:	f8 94       	cli
     f8a:	0f 92       	push	r0
     f8c:	f8 01       	movw	r30, r16
     f8e:	85 8d       	ldd	r24, Z+29	; 0x1d
     f90:	8f 3f       	cpi	r24, 0xFF	; 255
     f92:	09 f4       	brne	.+2      	; 0xf96 <xQueueGenericReceive+0xb4>
     f94:	15 8e       	std	Z+29, r1	; 0x1d
     f96:	f8 01       	movw	r30, r16
     f98:	86 8d       	ldd	r24, Z+30	; 0x1e
     f9a:	8f 3f       	cpi	r24, 0xFF	; 255
     f9c:	09 f4       	brne	.+2      	; 0xfa0 <xQueueGenericReceive+0xbe>
     f9e:	16 8e       	std	Z+30, r1	; 0x1e

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     fa0:	0f 90       	pop	r0
     fa2:	0f be       	out	0x3f, r0	; 63
     fa4:	be 01       	movw	r22, r28
     fa6:	6c 5f       	subi	r22, 0xFC	; 252
     fa8:	7f 4f       	sbci	r23, 0xFF	; 255
     faa:	ce 01       	movw	r24, r28
     fac:	01 96       	adiw	r24, 0x01	; 1
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     fae:	1b d4       	rcall	.+2102   	; 0x17e6 <xTaskCheckForTimeOut>
     fb0:	81 11       	cpse	r24, r1
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     fb2:	14 c0       	rjmp	.+40     	; 0xfdc <xQueueGenericReceive+0xfa>
     fb4:	c8 01       	movw	r24, r16
     fb6:	ec dd       	rcall	.-1064   	; 0xb90 <prvIsQueueEmpty>
				prvUnlockQueue( pxQueue );
     fb8:	88 23       	and	r24, r24
				if( xTaskResumeAll() == pdFALSE )
     fba:	61 f0       	breq	.+24     	; 0xfd4 <xQueueGenericReceive+0xf2>
     fbc:	6c 81       	ldd	r22, Y+4	; 0x04
				{
					portYIELD_WITHIN_API();
     fbe:	7d 81       	ldd	r23, Y+5	; 0x05
     fc0:	c8 01       	movw	r24, r16
     fc2:	41 96       	adiw	r24, 0x11	; 17
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     fc4:	af d3       	rcall	.+1886   	; 0x1724 <vTaskPlaceOnEventList>
     fc6:	c8 01       	movw	r24, r16
     fc8:	5e de       	rcall	.-836    	; 0xc86 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     fca:	af d2       	rcall	.+1374   	; 0x152a <xTaskResumeAll>
     fcc:	81 11       	cpse	r24, r1
     fce:	9f cf       	rjmp	.-194    	; 0xf0e <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     fd0:	f7 dc       	rcall	.-1554   	; 0x9c0 <vPortYield>
     fd2:	9d cf       	rjmp	.-198    	; 0xf0e <xQueueGenericReceive+0x2c>
     fd4:	c8 01       	movw	r24, r16
			( void ) xTaskResumeAll();
     fd6:	57 de       	rcall	.-850    	; 0xc86 <prvUnlockQueue>
     fd8:	a8 d2       	rcall	.+1360   	; 0x152a <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     fda:	99 cf       	rjmp	.-206    	; 0xf0e <xQueueGenericReceive+0x2c>
     fdc:	c8 01       	movw	r24, r16
     fde:	53 de       	rcall	.-858    	; 0xc86 <prvUnlockQueue>
     fe0:	a4 d2       	rcall	.+1352   	; 0x152a <xTaskResumeAll>
     fe2:	c8 01       	movw	r24, r16
     fe4:	d5 dd       	rcall	.-1110   	; 0xb90 <prvIsQueueEmpty>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
     fe6:	88 23       	and	r24, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
     fe8:	09 f4       	brne	.+2      	; 0xfec <xQueueGenericReceive+0x10a>
     fea:	91 cf       	rjmp	.-222    	; 0xf0e <xQueueGenericReceive+0x2c>
     fec:	80 e0       	ldi	r24, 0x00	; 0
     fee:	0f 90       	pop	r0
     ff0:	0f 90       	pop	r0
     ff2:	0f 90       	pop	r0
     ff4:	0f 90       	pop	r0
     ff6:	0f 90       	pop	r0
     ff8:	df 91       	pop	r29
     ffa:	cf 91       	pop	r28
     ffc:	1f 91       	pop	r17
     ffe:	0f 91       	pop	r16
    1000:	ff 90       	pop	r15
    1002:	ef 90       	pop	r14
    1004:	df 90       	pop	r13
    1006:	cf 90       	pop	r12
    1008:	bf 90       	pop	r11
    100a:	9f 90       	pop	r9
    100c:	8f 90       	pop	r8
    100e:	08 95       	ret

00001010 <prvResetNextTaskUnblockTime>:
			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
		}
		taskEXIT_CRITICAL();

		return xReturn;
	}
    1010:	e0 91 e4 07 	lds	r30, 0x07E4	; 0x8007e4 <pxDelayedTaskList>
    1014:	f0 91 e5 07 	lds	r31, 0x07E5	; 0x8007e5 <pxDelayedTaskList+0x1>
    1018:	80 81       	ld	r24, Z
    101a:	81 11       	cpse	r24, r1
    101c:	07 c0       	rjmp	.+14     	; 0x102c <prvResetNextTaskUnblockTime+0x1c>
    101e:	8f ef       	ldi	r24, 0xFF	; 255
    1020:	9f ef       	ldi	r25, 0xFF	; 255
    1022:	90 93 cf 07 	sts	0x07CF, r25	; 0x8007cf <xNextTaskUnblockTime+0x1>
    1026:	80 93 ce 07 	sts	0x07CE, r24	; 0x8007ce <xNextTaskUnblockTime>
    102a:	08 95       	ret
    102c:	e0 91 e4 07 	lds	r30, 0x07E4	; 0x8007e4 <pxDelayedTaskList>
    1030:	f0 91 e5 07 	lds	r31, 0x07E5	; 0x8007e5 <pxDelayedTaskList+0x1>
    1034:	05 80       	ldd	r0, Z+5	; 0x05
    1036:	f6 81       	ldd	r31, Z+6	; 0x06
    1038:	e0 2d       	mov	r30, r0
    103a:	06 80       	ldd	r0, Z+6	; 0x06
    103c:	f7 81       	ldd	r31, Z+7	; 0x07
    103e:	e0 2d       	mov	r30, r0
    1040:	82 81       	ldd	r24, Z+2	; 0x02
    1042:	93 81       	ldd	r25, Z+3	; 0x03
    1044:	90 93 cf 07 	sts	0x07CF, r25	; 0x8007cf <xNextTaskUnblockTime+0x1>
    1048:	80 93 ce 07 	sts	0x07CE, r24	; 0x8007ce <xNextTaskUnblockTime>
    104c:	08 95       	ret

0000104e <prvInitialiseNewTask>:
    104e:	6f 92       	push	r6
    1050:	7f 92       	push	r7
    1052:	8f 92       	push	r8
    1054:	9f 92       	push	r9
    1056:	af 92       	push	r10
    1058:	bf 92       	push	r11
    105a:	cf 92       	push	r12
    105c:	df 92       	push	r13
    105e:	ef 92       	push	r14
    1060:	0f 93       	push	r16
    1062:	1f 93       	push	r17
    1064:	cf 93       	push	r28
    1066:	df 93       	push	r29
    1068:	cd b7       	in	r28, 0x3d	; 61
    106a:	de b7       	in	r29, 0x3e	; 62
    106c:	4c 01       	movw	r8, r24
    106e:	f5 01       	movw	r30, r10
    1070:	87 89       	ldd	r24, Z+23	; 0x17
    1072:	90 8d       	ldd	r25, Z+24	; 0x18
    1074:	21 50       	subi	r18, 0x01	; 1
    1076:	31 09       	sbc	r19, r1
    1078:	3c 01       	movw	r6, r24
    107a:	62 0e       	add	r6, r18
    107c:	73 1e       	adc	r7, r19
    107e:	20 e0       	ldi	r18, 0x00	; 0
    1080:	0f c0       	rjmp	.+30     	; 0x10a0 <prvInitialiseNewTask+0x52>
    1082:	82 2f       	mov	r24, r18
    1084:	90 e0       	ldi	r25, 0x00	; 0
    1086:	fb 01       	movw	r30, r22
    1088:	e8 0f       	add	r30, r24
    108a:	f9 1f       	adc	r31, r25
    108c:	30 81       	ld	r19, Z
    108e:	d5 01       	movw	r26, r10
    1090:	a8 0f       	add	r26, r24
    1092:	b9 1f       	adc	r27, r25
    1094:	59 96       	adiw	r26, 0x19	; 25
    1096:	3c 93       	st	X, r19
    1098:	80 81       	ld	r24, Z
    109a:	88 23       	and	r24, r24
    109c:	19 f0       	breq	.+6      	; 0x10a4 <prvInitialiseNewTask+0x56>
    109e:	2f 5f       	subi	r18, 0xFF	; 255
    10a0:	28 30       	cpi	r18, 0x08	; 8
    10a2:	78 f3       	brcs	.-34     	; 0x1082 <prvInitialiseNewTask+0x34>
    10a4:	f5 01       	movw	r30, r10
    10a6:	10 a2       	std	Z+32, r1	; 0x20
    10a8:	f4 e0       	ldi	r31, 0x04	; 4
    10aa:	fe 15       	cp	r31, r14
    10ac:	18 f4       	brcc	.+6      	; 0x10b4 <prvInitialiseNewTask+0x66>
    10ae:	68 94       	set
    10b0:	ee 24       	eor	r14, r14
    10b2:	e2 f8       	bld	r14, 2
    10b4:	f5 01       	movw	r30, r10
    10b6:	e6 8a       	std	Z+22, r14	; 0x16
    10b8:	c5 01       	movw	r24, r10
    10ba:	02 96       	adiw	r24, 0x02	; 2
    10bc:	61 db       	rcall	.-2366   	; 0x780 <vListInitialiseItem>
    10be:	c5 01       	movw	r24, r10
    10c0:	0c 96       	adiw	r24, 0x0c	; 12
    10c2:	5e db       	rcall	.-2372   	; 0x780 <vListInitialiseItem>
    10c4:	f5 01       	movw	r30, r10
    10c6:	b1 86       	std	Z+9, r11	; 0x09
    10c8:	a0 86       	std	Z+8, r10	; 0x08
    10ca:	85 e0       	ldi	r24, 0x05	; 5
    10cc:	90 e0       	ldi	r25, 0x00	; 0
    10ce:	8e 19       	sub	r24, r14
    10d0:	91 09       	sbc	r25, r1
    10d2:	95 87       	std	Z+13, r25	; 0x0d
    10d4:	84 87       	std	Z+12, r24	; 0x0c
    10d6:	b3 8a       	std	Z+19, r11	; 0x13
    10d8:	a2 8a       	std	Z+18, r10	; 0x12
    10da:	11 a2       	std	Z+33, r1	; 0x21
    10dc:	12 a2       	std	Z+34, r1	; 0x22
    10de:	13 a2       	std	Z+35, r1	; 0x23
    10e0:	14 a2       	std	Z+36, r1	; 0x24
    10e2:	15 a2       	std	Z+37, r1	; 0x25
    10e4:	a8 01       	movw	r20, r16
    10e6:	b4 01       	movw	r22, r8
    10e8:	c3 01       	movw	r24, r6
    10ea:	d0 db       	rcall	.-2144   	; 0x88c <pxPortInitialiseStack>
    10ec:	f5 01       	movw	r30, r10
    10ee:	91 83       	std	Z+1, r25	; 0x01
    10f0:	80 83       	st	Z, r24
    10f2:	c1 14       	cp	r12, r1
    10f4:	d1 04       	cpc	r13, r1
    10f6:	19 f0       	breq	.+6      	; 0x10fe <prvInitialiseNewTask+0xb0>
    10f8:	f6 01       	movw	r30, r12
    10fa:	b1 82       	std	Z+1, r11	; 0x01
    10fc:	a0 82       	st	Z, r10
    10fe:	df 91       	pop	r29
    1100:	cf 91       	pop	r28
    1102:	1f 91       	pop	r17
    1104:	0f 91       	pop	r16
    1106:	ef 90       	pop	r14
    1108:	df 90       	pop	r13
    110a:	cf 90       	pop	r12
    110c:	bf 90       	pop	r11
    110e:	af 90       	pop	r10
    1110:	9f 90       	pop	r9
    1112:	8f 90       	pop	r8
    1114:	7f 90       	pop	r7
    1116:	6f 90       	pop	r6
    1118:	08 95       	ret

0000111a <prvIdleTask>:
    111a:	80 91 f8 07 	lds	r24, 0x07F8	; 0x8007f8 <pxReadyTasksLists>
    111e:	82 30       	cpi	r24, 0x02	; 2
    1120:	e0 f3       	brcs	.-8      	; 0x111a <prvIdleTask>
    1122:	4e dc       	rcall	.-1892   	; 0x9c0 <vPortYield>
    1124:	fa cf       	rjmp	.-12     	; 0x111a <prvIdleTask>

00001126 <prvInitialiseTaskLists>:
    1126:	cf 93       	push	r28
    1128:	c0 e0       	ldi	r28, 0x00	; 0
    112a:	0f c0       	rjmp	.+30     	; 0x114a <prvInitialiseTaskLists+0x24>
    112c:	8c 2f       	mov	r24, r28
    112e:	90 e0       	ldi	r25, 0x00	; 0
    1130:	9c 01       	movw	r18, r24
    1132:	22 0f       	add	r18, r18
    1134:	33 1f       	adc	r19, r19
    1136:	22 0f       	add	r18, r18
    1138:	33 1f       	adc	r19, r19
    113a:	22 0f       	add	r18, r18
    113c:	33 1f       	adc	r19, r19
    113e:	82 0f       	add	r24, r18
    1140:	93 1f       	adc	r25, r19
    1142:	88 50       	subi	r24, 0x08	; 8
    1144:	98 4f       	sbci	r25, 0xF8	; 248
    1146:	0e db       	rcall	.-2532   	; 0x764 <vListInitialise>
    1148:	cf 5f       	subi	r28, 0xFF	; 255
    114a:	c5 30       	cpi	r28, 0x05	; 5
    114c:	78 f3       	brcs	.-34     	; 0x112c <prvInitialiseTaskLists+0x6>
    114e:	8f ee       	ldi	r24, 0xEF	; 239
    1150:	97 e0       	ldi	r25, 0x07	; 7
    1152:	08 db       	rcall	.-2544   	; 0x764 <vListInitialise>
    1154:	86 ee       	ldi	r24, 0xE6	; 230
    1156:	97 e0       	ldi	r25, 0x07	; 7
    1158:	05 db       	rcall	.-2550   	; 0x764 <vListInitialise>
    115a:	89 ed       	ldi	r24, 0xD9	; 217
    115c:	97 e0       	ldi	r25, 0x07	; 7
    115e:	02 db       	rcall	.-2556   	; 0x764 <vListInitialise>
    1160:	8f ee       	ldi	r24, 0xEF	; 239
    1162:	97 e0       	ldi	r25, 0x07	; 7
    1164:	90 93 e5 07 	sts	0x07E5, r25	; 0x8007e5 <pxDelayedTaskList+0x1>
    1168:	80 93 e4 07 	sts	0x07E4, r24	; 0x8007e4 <pxDelayedTaskList>
    116c:	86 ee       	ldi	r24, 0xE6	; 230
    116e:	97 e0       	ldi	r25, 0x07	; 7
    1170:	90 93 e3 07 	sts	0x07E3, r25	; 0x8007e3 <pxOverflowDelayedTaskList+0x1>
    1174:	80 93 e2 07 	sts	0x07E2, r24	; 0x8007e2 <pxOverflowDelayedTaskList>
    1178:	cf 91       	pop	r28
    117a:	08 95       	ret

0000117c <prvAddNewTaskToReadyList>:
    117c:	cf 93       	push	r28
    117e:	df 93       	push	r29
    1180:	ec 01       	movw	r28, r24
    1182:	0f b6       	in	r0, 0x3f	; 63
    1184:	f8 94       	cli
    1186:	0f 92       	push	r0
    1188:	80 91 d8 07 	lds	r24, 0x07D8	; 0x8007d8 <uxCurrentNumberOfTasks>
    118c:	8f 5f       	subi	r24, 0xFF	; 255
    118e:	80 93 d8 07 	sts	0x07D8, r24	; 0x8007d8 <uxCurrentNumberOfTasks>
    1192:	80 91 25 08 	lds	r24, 0x0825	; 0x800825 <pxCurrentTCB>
    1196:	90 91 26 08 	lds	r25, 0x0826	; 0x800826 <pxCurrentTCB+0x1>
    119a:	89 2b       	or	r24, r25
    119c:	51 f4       	brne	.+20     	; 0x11b2 <prvAddNewTaskToReadyList+0x36>
    119e:	d0 93 26 08 	sts	0x0826, r29	; 0x800826 <pxCurrentTCB+0x1>
    11a2:	c0 93 25 08 	sts	0x0825, r28	; 0x800825 <pxCurrentTCB>
    11a6:	80 91 d8 07 	lds	r24, 0x07D8	; 0x8007d8 <uxCurrentNumberOfTasks>
    11aa:	81 30       	cpi	r24, 0x01	; 1
    11ac:	91 f4       	brne	.+36     	; 0x11d2 <prvAddNewTaskToReadyList+0x56>
    11ae:	bb df       	rcall	.-138    	; 0x1126 <prvInitialiseTaskLists>
    11b0:	10 c0       	rjmp	.+32     	; 0x11d2 <prvAddNewTaskToReadyList+0x56>
    11b2:	80 91 d4 07 	lds	r24, 0x07D4	; 0x8007d4 <xSchedulerRunning>
    11b6:	81 11       	cpse	r24, r1
    11b8:	0c c0       	rjmp	.+24     	; 0x11d2 <prvAddNewTaskToReadyList+0x56>
    11ba:	e0 91 25 08 	lds	r30, 0x0825	; 0x800825 <pxCurrentTCB>
    11be:	f0 91 26 08 	lds	r31, 0x0826	; 0x800826 <pxCurrentTCB+0x1>
    11c2:	96 89       	ldd	r25, Z+22	; 0x16
    11c4:	8e 89       	ldd	r24, Y+22	; 0x16
    11c6:	89 17       	cp	r24, r25
    11c8:	20 f0       	brcs	.+8      	; 0x11d2 <prvAddNewTaskToReadyList+0x56>
    11ca:	d0 93 26 08 	sts	0x0826, r29	; 0x800826 <pxCurrentTCB+0x1>
    11ce:	c0 93 25 08 	sts	0x0825, r28	; 0x800825 <pxCurrentTCB>
    11d2:	80 91 d0 07 	lds	r24, 0x07D0	; 0x8007d0 <uxTaskNumber>
    11d6:	8f 5f       	subi	r24, 0xFF	; 255
    11d8:	80 93 d0 07 	sts	0x07D0, r24	; 0x8007d0 <uxTaskNumber>
    11dc:	8e 89       	ldd	r24, Y+22	; 0x16
    11de:	90 91 d5 07 	lds	r25, 0x07D5	; 0x8007d5 <uxTopReadyPriority>
    11e2:	98 17       	cp	r25, r24
    11e4:	10 f4       	brcc	.+4      	; 0x11ea <prvAddNewTaskToReadyList+0x6e>
    11e6:	80 93 d5 07 	sts	0x07D5, r24	; 0x8007d5 <uxTopReadyPriority>
    11ea:	90 e0       	ldi	r25, 0x00	; 0
    11ec:	9c 01       	movw	r18, r24
    11ee:	22 0f       	add	r18, r18
    11f0:	33 1f       	adc	r19, r19
    11f2:	22 0f       	add	r18, r18
    11f4:	33 1f       	adc	r19, r19
    11f6:	22 0f       	add	r18, r18
    11f8:	33 1f       	adc	r19, r19
    11fa:	82 0f       	add	r24, r18
    11fc:	93 1f       	adc	r25, r19
    11fe:	be 01       	movw	r22, r28
    1200:	6e 5f       	subi	r22, 0xFE	; 254
    1202:	7f 4f       	sbci	r23, 0xFF	; 255
    1204:	88 50       	subi	r24, 0x08	; 8
    1206:	98 4f       	sbci	r25, 0xF8	; 248
    1208:	bf da       	rcall	.-2690   	; 0x788 <vListInsertEnd>
    120a:	0f 90       	pop	r0
    120c:	0f be       	out	0x3f, r0	; 63
    120e:	80 91 d4 07 	lds	r24, 0x07D4	; 0x8007d4 <xSchedulerRunning>
    1212:	88 23       	and	r24, r24
    1214:	49 f0       	breq	.+18     	; 0x1228 <prvAddNewTaskToReadyList+0xac>
    1216:	e0 91 25 08 	lds	r30, 0x0825	; 0x800825 <pxCurrentTCB>
    121a:	f0 91 26 08 	lds	r31, 0x0826	; 0x800826 <pxCurrentTCB+0x1>
    121e:	96 89       	ldd	r25, Z+22	; 0x16
    1220:	8e 89       	ldd	r24, Y+22	; 0x16
    1222:	98 17       	cp	r25, r24
    1224:	08 f4       	brcc	.+2      	; 0x1228 <prvAddNewTaskToReadyList+0xac>
    1226:	cc db       	rcall	.-2152   	; 0x9c0 <vPortYield>
    1228:	df 91       	pop	r29
    122a:	cf 91       	pop	r28
    122c:	08 95       	ret

0000122e <prvAddCurrentTaskToDelayedList>:
    122e:	0f 93       	push	r16
    1230:	1f 93       	push	r17
    1232:	cf 93       	push	r28
    1234:	df 93       	push	r29
    1236:	ec 01       	movw	r28, r24
    1238:	00 91 d6 07 	lds	r16, 0x07D6	; 0x8007d6 <xTickCount>
    123c:	10 91 d7 07 	lds	r17, 0x07D7	; 0x8007d7 <xTickCount+0x1>
    1240:	80 91 25 08 	lds	r24, 0x0825	; 0x800825 <pxCurrentTCB>
    1244:	90 91 26 08 	lds	r25, 0x0826	; 0x800826 <pxCurrentTCB+0x1>
    1248:	02 96       	adiw	r24, 0x02	; 2
    124a:	f0 da       	rcall	.-2592   	; 0x82c <uxListRemove>
    124c:	c0 0f       	add	r28, r16
    124e:	d1 1f       	adc	r29, r17
    1250:	e0 91 25 08 	lds	r30, 0x0825	; 0x800825 <pxCurrentTCB>
    1254:	f0 91 26 08 	lds	r31, 0x0826	; 0x800826 <pxCurrentTCB+0x1>
    1258:	d3 83       	std	Z+3, r29	; 0x03
    125a:	c2 83       	std	Z+2, r28	; 0x02
    125c:	c0 17       	cp	r28, r16
    125e:	d1 07       	cpc	r29, r17
    1260:	60 f4       	brcc	.+24     	; 0x127a <prvAddCurrentTaskToDelayedList+0x4c>
    1262:	60 91 25 08 	lds	r22, 0x0825	; 0x800825 <pxCurrentTCB>
    1266:	70 91 26 08 	lds	r23, 0x0826	; 0x800826 <pxCurrentTCB+0x1>
    126a:	80 91 e2 07 	lds	r24, 0x07E2	; 0x8007e2 <pxOverflowDelayedTaskList>
    126e:	90 91 e3 07 	lds	r25, 0x07E3	; 0x8007e3 <pxOverflowDelayedTaskList+0x1>
    1272:	6e 5f       	subi	r22, 0xFE	; 254
    1274:	7f 4f       	sbci	r23, 0xFF	; 255
    1276:	a9 da       	rcall	.-2734   	; 0x7ca <vListInsert>
    1278:	16 c0       	rjmp	.+44     	; 0x12a6 <prvAddCurrentTaskToDelayedList+0x78>
    127a:	60 91 25 08 	lds	r22, 0x0825	; 0x800825 <pxCurrentTCB>
    127e:	70 91 26 08 	lds	r23, 0x0826	; 0x800826 <pxCurrentTCB+0x1>
    1282:	80 91 e4 07 	lds	r24, 0x07E4	; 0x8007e4 <pxDelayedTaskList>
    1286:	90 91 e5 07 	lds	r25, 0x07E5	; 0x8007e5 <pxDelayedTaskList+0x1>
    128a:	6e 5f       	subi	r22, 0xFE	; 254
    128c:	7f 4f       	sbci	r23, 0xFF	; 255
    128e:	9d da       	rcall	.-2758   	; 0x7ca <vListInsert>
    1290:	80 91 ce 07 	lds	r24, 0x07CE	; 0x8007ce <xNextTaskUnblockTime>
    1294:	90 91 cf 07 	lds	r25, 0x07CF	; 0x8007cf <xNextTaskUnblockTime+0x1>
    1298:	c8 17       	cp	r28, r24
    129a:	d9 07       	cpc	r29, r25
    129c:	20 f4       	brcc	.+8      	; 0x12a6 <prvAddCurrentTaskToDelayedList+0x78>
    129e:	d0 93 cf 07 	sts	0x07CF, r29	; 0x8007cf <xNextTaskUnblockTime+0x1>
    12a2:	c0 93 ce 07 	sts	0x07CE, r28	; 0x8007ce <xNextTaskUnblockTime>
    12a6:	df 91       	pop	r29
    12a8:	cf 91       	pop	r28
    12aa:	1f 91       	pop	r17
    12ac:	0f 91       	pop	r16
    12ae:	08 95       	ret

000012b0 <xTaskCreate>:
    12b0:	2f 92       	push	r2
    12b2:	3f 92       	push	r3
    12b4:	4f 92       	push	r4
    12b6:	5f 92       	push	r5
    12b8:	6f 92       	push	r6
    12ba:	7f 92       	push	r7
    12bc:	8f 92       	push	r8
    12be:	9f 92       	push	r9
    12c0:	af 92       	push	r10
    12c2:	bf 92       	push	r11
    12c4:	cf 92       	push	r12
    12c6:	df 92       	push	r13
    12c8:	ef 92       	push	r14
    12ca:	ff 92       	push	r15
    12cc:	0f 93       	push	r16
    12ce:	1f 93       	push	r17
    12d0:	cf 93       	push	r28
    12d2:	df 93       	push	r29
    12d4:	3c 01       	movw	r6, r24
    12d6:	1b 01       	movw	r2, r22
    12d8:	5a 01       	movw	r10, r20
    12da:	29 01       	movw	r4, r18
    12dc:	ca 01       	movw	r24, r20
    12de:	24 dc       	rcall	.-1976   	; 0xb28 <pvPortMalloc>
    12e0:	6c 01       	movw	r12, r24
    12e2:	89 2b       	or	r24, r25
    12e4:	61 f0       	breq	.+24     	; 0x12fe <xTaskCreate+0x4e>
    12e6:	86 e2       	ldi	r24, 0x26	; 38
    12e8:	90 e0       	ldi	r25, 0x00	; 0
    12ea:	1e dc       	rcall	.-1988   	; 0xb28 <pvPortMalloc>
    12ec:	ec 01       	movw	r28, r24
    12ee:	89 2b       	or	r24, r25
    12f0:	19 f0       	breq	.+6      	; 0x12f8 <xTaskCreate+0x48>
    12f2:	d8 8e       	std	Y+24, r13	; 0x18
    12f4:	cf 8a       	std	Y+23, r12	; 0x17
    12f6:	05 c0       	rjmp	.+10     	; 0x1302 <xTaskCreate+0x52>
    12f8:	c6 01       	movw	r24, r12
    12fa:	49 dc       	rcall	.-1902   	; 0xb8e <vPortFree>
    12fc:	02 c0       	rjmp	.+4      	; 0x1302 <xTaskCreate+0x52>
    12fe:	c0 e0       	ldi	r28, 0x00	; 0
    1300:	d0 e0       	ldi	r29, 0x00	; 0
    1302:	20 97       	sbiw	r28, 0x00	; 0
    1304:	81 f0       	breq	.+32     	; 0x1326 <xTaskCreate+0x76>
    1306:	95 01       	movw	r18, r10
    1308:	40 e0       	ldi	r20, 0x00	; 0
    130a:	50 e0       	ldi	r21, 0x00	; 0
    130c:	81 2c       	mov	r8, r1
    130e:	91 2c       	mov	r9, r1
    1310:	5e 01       	movw	r10, r28
    1312:	67 01       	movw	r12, r14
    1314:	e0 2e       	mov	r14, r16
    1316:	82 01       	movw	r16, r4
    1318:	b1 01       	movw	r22, r2
    131a:	c3 01       	movw	r24, r6
    131c:	98 de       	rcall	.-720    	; 0x104e <prvInitialiseNewTask>
    131e:	ce 01       	movw	r24, r28
    1320:	2d df       	rcall	.-422    	; 0x117c <prvAddNewTaskToReadyList>
    1322:	81 e0       	ldi	r24, 0x01	; 1
    1324:	01 c0       	rjmp	.+2      	; 0x1328 <xTaskCreate+0x78>
    1326:	8f ef       	ldi	r24, 0xFF	; 255
    1328:	df 91       	pop	r29
    132a:	cf 91       	pop	r28
    132c:	1f 91       	pop	r17
    132e:	0f 91       	pop	r16
    1330:	ff 90       	pop	r15
    1332:	ef 90       	pop	r14
    1334:	df 90       	pop	r13
    1336:	cf 90       	pop	r12
    1338:	bf 90       	pop	r11
    133a:	af 90       	pop	r10
    133c:	9f 90       	pop	r9
    133e:	8f 90       	pop	r8
    1340:	7f 90       	pop	r7
    1342:	6f 90       	pop	r6
    1344:	5f 90       	pop	r5
    1346:	4f 90       	pop	r4
    1348:	3f 90       	pop	r3
    134a:	2f 90       	pop	r2
    134c:	08 95       	ret

0000134e <vTaskStartScheduler>:
    134e:	ef 92       	push	r14
    1350:	ff 92       	push	r15
    1352:	0f 93       	push	r16
    1354:	0f 2e       	mov	r0, r31
    1356:	fc ec       	ldi	r31, 0xCC	; 204
    1358:	ef 2e       	mov	r14, r31
    135a:	f7 e0       	ldi	r31, 0x07	; 7
    135c:	ff 2e       	mov	r15, r31
    135e:	f0 2d       	mov	r31, r0
    1360:	00 e0       	ldi	r16, 0x00	; 0
    1362:	20 e0       	ldi	r18, 0x00	; 0
    1364:	30 e0       	ldi	r19, 0x00	; 0
    1366:	46 e9       	ldi	r20, 0x96	; 150
    1368:	50 e0       	ldi	r21, 0x00	; 0
    136a:	63 eb       	ldi	r22, 0xB3	; 179
    136c:	70 e0       	ldi	r23, 0x00	; 0
    136e:	8d e8       	ldi	r24, 0x8D	; 141
    1370:	98 e0       	ldi	r25, 0x08	; 8
    1372:	9e df       	rcall	.-196    	; 0x12b0 <xTaskCreate>
    1374:	81 30       	cpi	r24, 0x01	; 1
    1376:	79 f4       	brne	.+30     	; 0x1396 <vTaskStartScheduler+0x48>
    1378:	f8 94       	cli
    137a:	8f ef       	ldi	r24, 0xFF	; 255
    137c:	9f ef       	ldi	r25, 0xFF	; 255
    137e:	90 93 cf 07 	sts	0x07CF, r25	; 0x8007cf <xNextTaskUnblockTime+0x1>
    1382:	80 93 ce 07 	sts	0x07CE, r24	; 0x8007ce <xNextTaskUnblockTime>
    1386:	81 e0       	ldi	r24, 0x01	; 1
    1388:	80 93 d4 07 	sts	0x07D4, r24	; 0x8007d4 <xSchedulerRunning>
    138c:	10 92 d7 07 	sts	0x07D7, r1	; 0x8007d7 <xTickCount+0x1>
    1390:	10 92 d6 07 	sts	0x07D6, r1	; 0x8007d6 <xTickCount>
    1394:	e7 da       	rcall	.-2610   	; 0x964 <xPortStartScheduler>
    1396:	0f 91       	pop	r16
    1398:	ff 90       	pop	r15
    139a:	ef 90       	pop	r14
    139c:	08 95       	ret

0000139e <vTaskSuspendAll>:
    139e:	80 91 cb 07 	lds	r24, 0x07CB	; 0x8007cb <uxSchedulerSuspended>
    13a2:	8f 5f       	subi	r24, 0xFF	; 255
    13a4:	80 93 cb 07 	sts	0x07CB, r24	; 0x8007cb <uxSchedulerSuspended>
    13a8:	08 95       	ret

000013aa <xTaskGetTickCount>:
    13aa:	0f b6       	in	r0, 0x3f	; 63
    13ac:	f8 94       	cli
    13ae:	0f 92       	push	r0
    13b0:	80 91 d6 07 	lds	r24, 0x07D6	; 0x8007d6 <xTickCount>
    13b4:	90 91 d7 07 	lds	r25, 0x07D7	; 0x8007d7 <xTickCount+0x1>
    13b8:	0f 90       	pop	r0
    13ba:	0f be       	out	0x3f, r0	; 63
    13bc:	08 95       	ret

000013be <xTaskIncrementTick>:
    13be:	df 92       	push	r13
    13c0:	ef 92       	push	r14
    13c2:	ff 92       	push	r15
    13c4:	0f 93       	push	r16
    13c6:	1f 93       	push	r17
    13c8:	cf 93       	push	r28
    13ca:	df 93       	push	r29
    13cc:	80 91 cb 07 	lds	r24, 0x07CB	; 0x8007cb <uxSchedulerSuspended>
    13d0:	81 11       	cpse	r24, r1
    13d2:	93 c0       	rjmp	.+294    	; 0x14fa <xTaskIncrementTick+0x13c>
    13d4:	e0 90 d6 07 	lds	r14, 0x07D6	; 0x8007d6 <xTickCount>
    13d8:	f0 90 d7 07 	lds	r15, 0x07D7	; 0x8007d7 <xTickCount+0x1>
    13dc:	8f ef       	ldi	r24, 0xFF	; 255
    13de:	e8 1a       	sub	r14, r24
    13e0:	f8 0a       	sbc	r15, r24
    13e2:	f0 92 d7 07 	sts	0x07D7, r15	; 0x8007d7 <xTickCount+0x1>
    13e6:	e0 92 d6 07 	sts	0x07D6, r14	; 0x8007d6 <xTickCount>
    13ea:	e1 14       	cp	r14, r1
    13ec:	f1 04       	cpc	r15, r1
    13ee:	b1 f4       	brne	.+44     	; 0x141c <xTaskIncrementTick+0x5e>
    13f0:	80 91 e4 07 	lds	r24, 0x07E4	; 0x8007e4 <pxDelayedTaskList>
    13f4:	90 91 e5 07 	lds	r25, 0x07E5	; 0x8007e5 <pxDelayedTaskList+0x1>
    13f8:	20 91 e2 07 	lds	r18, 0x07E2	; 0x8007e2 <pxOverflowDelayedTaskList>
    13fc:	30 91 e3 07 	lds	r19, 0x07E3	; 0x8007e3 <pxOverflowDelayedTaskList+0x1>
    1400:	30 93 e5 07 	sts	0x07E5, r19	; 0x8007e5 <pxDelayedTaskList+0x1>
    1404:	20 93 e4 07 	sts	0x07E4, r18	; 0x8007e4 <pxDelayedTaskList>
    1408:	90 93 e3 07 	sts	0x07E3, r25	; 0x8007e3 <pxOverflowDelayedTaskList+0x1>
    140c:	80 93 e2 07 	sts	0x07E2, r24	; 0x8007e2 <pxOverflowDelayedTaskList>
    1410:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <xNumOfOverflows>
    1414:	8f 5f       	subi	r24, 0xFF	; 255
    1416:	80 93 d1 07 	sts	0x07D1, r24	; 0x8007d1 <xNumOfOverflows>
    141a:	fa dd       	rcall	.-1036   	; 0x1010 <prvResetNextTaskUnblockTime>
    141c:	80 91 ce 07 	lds	r24, 0x07CE	; 0x8007ce <xNextTaskUnblockTime>
    1420:	90 91 cf 07 	lds	r25, 0x07CF	; 0x8007cf <xNextTaskUnblockTime+0x1>
    1424:	e8 16       	cp	r14, r24
    1426:	f9 06       	cpc	r15, r25
    1428:	28 f4       	brcc	.+10     	; 0x1434 <xTaskIncrementTick+0x76>
    142a:	d1 2c       	mov	r13, r1
    142c:	50 c0       	rjmp	.+160    	; 0x14ce <xTaskIncrementTick+0x110>
    142e:	dd 24       	eor	r13, r13
    1430:	d3 94       	inc	r13
    1432:	01 c0       	rjmp	.+2      	; 0x1436 <xTaskIncrementTick+0x78>
    1434:	d1 2c       	mov	r13, r1
    1436:	e0 91 e4 07 	lds	r30, 0x07E4	; 0x8007e4 <pxDelayedTaskList>
    143a:	f0 91 e5 07 	lds	r31, 0x07E5	; 0x8007e5 <pxDelayedTaskList+0x1>
    143e:	80 81       	ld	r24, Z
    1440:	81 11       	cpse	r24, r1
    1442:	07 c0       	rjmp	.+14     	; 0x1452 <xTaskIncrementTick+0x94>
    1444:	8f ef       	ldi	r24, 0xFF	; 255
    1446:	9f ef       	ldi	r25, 0xFF	; 255
    1448:	90 93 cf 07 	sts	0x07CF, r25	; 0x8007cf <xNextTaskUnblockTime+0x1>
    144c:	80 93 ce 07 	sts	0x07CE, r24	; 0x8007ce <xNextTaskUnblockTime>
    1450:	3e c0       	rjmp	.+124    	; 0x14ce <xTaskIncrementTick+0x110>
    1452:	e0 91 e4 07 	lds	r30, 0x07E4	; 0x8007e4 <pxDelayedTaskList>
    1456:	f0 91 e5 07 	lds	r31, 0x07E5	; 0x8007e5 <pxDelayedTaskList+0x1>
    145a:	05 80       	ldd	r0, Z+5	; 0x05
    145c:	f6 81       	ldd	r31, Z+6	; 0x06
    145e:	e0 2d       	mov	r30, r0
    1460:	c6 81       	ldd	r28, Z+6	; 0x06
    1462:	d7 81       	ldd	r29, Z+7	; 0x07
    1464:	8a 81       	ldd	r24, Y+2	; 0x02
    1466:	9b 81       	ldd	r25, Y+3	; 0x03
    1468:	e8 16       	cp	r14, r24
    146a:	f9 06       	cpc	r15, r25
    146c:	28 f4       	brcc	.+10     	; 0x1478 <xTaskIncrementTick+0xba>
    146e:	90 93 cf 07 	sts	0x07CF, r25	; 0x8007cf <xNextTaskUnblockTime+0x1>
    1472:	80 93 ce 07 	sts	0x07CE, r24	; 0x8007ce <xNextTaskUnblockTime>
    1476:	2b c0       	rjmp	.+86     	; 0x14ce <xTaskIncrementTick+0x110>
    1478:	8e 01       	movw	r16, r28
    147a:	0e 5f       	subi	r16, 0xFE	; 254
    147c:	1f 4f       	sbci	r17, 0xFF	; 255
    147e:	c8 01       	movw	r24, r16
    1480:	d5 d9       	rcall	.-3158   	; 0x82c <uxListRemove>
    1482:	8c 89       	ldd	r24, Y+20	; 0x14
    1484:	9d 89       	ldd	r25, Y+21	; 0x15
    1486:	89 2b       	or	r24, r25
    1488:	19 f0       	breq	.+6      	; 0x1490 <xTaskIncrementTick+0xd2>
    148a:	ce 01       	movw	r24, r28
    148c:	0c 96       	adiw	r24, 0x0c	; 12
    148e:	ce d9       	rcall	.-3172   	; 0x82c <uxListRemove>
    1490:	8e 89       	ldd	r24, Y+22	; 0x16
    1492:	90 91 d5 07 	lds	r25, 0x07D5	; 0x8007d5 <uxTopReadyPriority>
    1496:	98 17       	cp	r25, r24
    1498:	10 f4       	brcc	.+4      	; 0x149e <xTaskIncrementTick+0xe0>
    149a:	80 93 d5 07 	sts	0x07D5, r24	; 0x8007d5 <uxTopReadyPriority>
    149e:	90 e0       	ldi	r25, 0x00	; 0
    14a0:	9c 01       	movw	r18, r24
    14a2:	22 0f       	add	r18, r18
    14a4:	33 1f       	adc	r19, r19
    14a6:	22 0f       	add	r18, r18
    14a8:	33 1f       	adc	r19, r19
    14aa:	22 0f       	add	r18, r18
    14ac:	33 1f       	adc	r19, r19
    14ae:	82 0f       	add	r24, r18
    14b0:	93 1f       	adc	r25, r19
    14b2:	b8 01       	movw	r22, r16
    14b4:	88 50       	subi	r24, 0x08	; 8
    14b6:	98 4f       	sbci	r25, 0xF8	; 248
    14b8:	67 d9       	rcall	.-3378   	; 0x788 <vListInsertEnd>
    14ba:	9e 89       	ldd	r25, Y+22	; 0x16
    14bc:	e0 91 25 08 	lds	r30, 0x0825	; 0x800825 <pxCurrentTCB>
    14c0:	f0 91 26 08 	lds	r31, 0x0826	; 0x800826 <pxCurrentTCB+0x1>
    14c4:	86 89       	ldd	r24, Z+22	; 0x16
    14c6:	98 17       	cp	r25, r24
    14c8:	08 f0       	brcs	.+2      	; 0x14cc <xTaskIncrementTick+0x10e>
    14ca:	b1 cf       	rjmp	.-158    	; 0x142e <xTaskIncrementTick+0x70>
    14cc:	b4 cf       	rjmp	.-152    	; 0x1436 <xTaskIncrementTick+0x78>
    14ce:	e0 91 25 08 	lds	r30, 0x0825	; 0x800825 <pxCurrentTCB>
    14d2:	f0 91 26 08 	lds	r31, 0x0826	; 0x800826 <pxCurrentTCB+0x1>
    14d6:	86 89       	ldd	r24, Z+22	; 0x16
    14d8:	90 e0       	ldi	r25, 0x00	; 0
    14da:	fc 01       	movw	r30, r24
    14dc:	ee 0f       	add	r30, r30
    14de:	ff 1f       	adc	r31, r31
    14e0:	ee 0f       	add	r30, r30
    14e2:	ff 1f       	adc	r31, r31
    14e4:	ee 0f       	add	r30, r30
    14e6:	ff 1f       	adc	r31, r31
    14e8:	8e 0f       	add	r24, r30
    14ea:	9f 1f       	adc	r25, r31
    14ec:	fc 01       	movw	r30, r24
    14ee:	e8 50       	subi	r30, 0x08	; 8
    14f0:	f8 4f       	sbci	r31, 0xF8	; 248
    14f2:	80 81       	ld	r24, Z
    14f4:	82 30       	cpi	r24, 0x02	; 2
    14f6:	40 f4       	brcc	.+16     	; 0x1508 <xTaskIncrementTick+0x14a>
    14f8:	09 c0       	rjmp	.+18     	; 0x150c <xTaskIncrementTick+0x14e>
    14fa:	80 91 d3 07 	lds	r24, 0x07D3	; 0x8007d3 <uxPendedTicks>
    14fe:	8f 5f       	subi	r24, 0xFF	; 255
    1500:	80 93 d3 07 	sts	0x07D3, r24	; 0x8007d3 <uxPendedTicks>
    1504:	d1 2c       	mov	r13, r1
    1506:	02 c0       	rjmp	.+4      	; 0x150c <xTaskIncrementTick+0x14e>
    1508:	dd 24       	eor	r13, r13
    150a:	d3 94       	inc	r13
    150c:	80 91 d2 07 	lds	r24, 0x07D2	; 0x8007d2 <xYieldPending>
    1510:	88 23       	and	r24, r24
    1512:	11 f0       	breq	.+4      	; 0x1518 <xTaskIncrementTick+0x15a>
    1514:	dd 24       	eor	r13, r13
    1516:	d3 94       	inc	r13
    1518:	8d 2d       	mov	r24, r13
    151a:	df 91       	pop	r29
    151c:	cf 91       	pop	r28
    151e:	1f 91       	pop	r17
    1520:	0f 91       	pop	r16
    1522:	ff 90       	pop	r15
    1524:	ef 90       	pop	r14
    1526:	df 90       	pop	r13
    1528:	08 95       	ret

0000152a <xTaskResumeAll>:
    152a:	0f 93       	push	r16
    152c:	1f 93       	push	r17
    152e:	cf 93       	push	r28
    1530:	df 93       	push	r29
    1532:	0f b6       	in	r0, 0x3f	; 63
    1534:	f8 94       	cli
    1536:	0f 92       	push	r0
    1538:	80 91 cb 07 	lds	r24, 0x07CB	; 0x8007cb <uxSchedulerSuspended>
    153c:	81 50       	subi	r24, 0x01	; 1
    153e:	80 93 cb 07 	sts	0x07CB, r24	; 0x8007cb <uxSchedulerSuspended>
    1542:	80 91 cb 07 	lds	r24, 0x07CB	; 0x8007cb <uxSchedulerSuspended>
    1546:	81 11       	cpse	r24, r1
    1548:	52 c0       	rjmp	.+164    	; 0x15ee <xTaskResumeAll+0xc4>
    154a:	80 91 d8 07 	lds	r24, 0x07D8	; 0x8007d8 <uxCurrentNumberOfTasks>
    154e:	81 11       	cpse	r24, r1
    1550:	30 c0       	rjmp	.+96     	; 0x15b2 <xTaskResumeAll+0x88>
    1552:	50 c0       	rjmp	.+160    	; 0x15f4 <xTaskResumeAll+0xca>
    1554:	e0 91 de 07 	lds	r30, 0x07DE	; 0x8007de <xPendingReadyList+0x5>
    1558:	f0 91 df 07 	lds	r31, 0x07DF	; 0x8007df <xPendingReadyList+0x6>
    155c:	c6 81       	ldd	r28, Z+6	; 0x06
    155e:	d7 81       	ldd	r29, Z+7	; 0x07
    1560:	ce 01       	movw	r24, r28
    1562:	0c 96       	adiw	r24, 0x0c	; 12
    1564:	63 d9       	rcall	.-3386   	; 0x82c <uxListRemove>
    1566:	8e 01       	movw	r16, r28
    1568:	0e 5f       	subi	r16, 0xFE	; 254
    156a:	1f 4f       	sbci	r17, 0xFF	; 255
    156c:	c8 01       	movw	r24, r16
    156e:	5e d9       	rcall	.-3396   	; 0x82c <uxListRemove>
    1570:	8e 89       	ldd	r24, Y+22	; 0x16
    1572:	90 91 d5 07 	lds	r25, 0x07D5	; 0x8007d5 <uxTopReadyPriority>
    1576:	98 17       	cp	r25, r24
    1578:	10 f4       	brcc	.+4      	; 0x157e <xTaskResumeAll+0x54>
    157a:	80 93 d5 07 	sts	0x07D5, r24	; 0x8007d5 <uxTopReadyPriority>
    157e:	90 e0       	ldi	r25, 0x00	; 0
    1580:	9c 01       	movw	r18, r24
    1582:	22 0f       	add	r18, r18
    1584:	33 1f       	adc	r19, r19
    1586:	22 0f       	add	r18, r18
    1588:	33 1f       	adc	r19, r19
    158a:	22 0f       	add	r18, r18
    158c:	33 1f       	adc	r19, r19
    158e:	82 0f       	add	r24, r18
    1590:	93 1f       	adc	r25, r19
    1592:	b8 01       	movw	r22, r16
    1594:	88 50       	subi	r24, 0x08	; 8
    1596:	98 4f       	sbci	r25, 0xF8	; 248
    1598:	f7 d8       	rcall	.-3602   	; 0x788 <vListInsertEnd>
    159a:	9e 89       	ldd	r25, Y+22	; 0x16
    159c:	e0 91 25 08 	lds	r30, 0x0825	; 0x800825 <pxCurrentTCB>
    15a0:	f0 91 26 08 	lds	r31, 0x0826	; 0x800826 <pxCurrentTCB+0x1>
    15a4:	86 89       	ldd	r24, Z+22	; 0x16
    15a6:	98 17       	cp	r25, r24
    15a8:	30 f0       	brcs	.+12     	; 0x15b6 <xTaskResumeAll+0x8c>
    15aa:	81 e0       	ldi	r24, 0x01	; 1
    15ac:	80 93 d2 07 	sts	0x07D2, r24	; 0x8007d2 <xYieldPending>
    15b0:	02 c0       	rjmp	.+4      	; 0x15b6 <xTaskResumeAll+0x8c>
    15b2:	c0 e0       	ldi	r28, 0x00	; 0
    15b4:	d0 e0       	ldi	r29, 0x00	; 0
    15b6:	80 91 d9 07 	lds	r24, 0x07D9	; 0x8007d9 <xPendingReadyList>
    15ba:	81 11       	cpse	r24, r1
    15bc:	cb cf       	rjmp	.-106    	; 0x1554 <xTaskResumeAll+0x2a>
    15be:	cd 2b       	or	r28, r29
    15c0:	09 f0       	breq	.+2      	; 0x15c4 <xTaskResumeAll+0x9a>
    15c2:	26 dd       	rcall	.-1460   	; 0x1010 <prvResetNextTaskUnblockTime>
    15c4:	c0 91 d3 07 	lds	r28, 0x07D3	; 0x8007d3 <uxPendedTicks>
    15c8:	cc 23       	and	r28, r28
    15ca:	51 f0       	breq	.+20     	; 0x15e0 <xTaskResumeAll+0xb6>
    15cc:	f8 de       	rcall	.-528    	; 0x13be <xTaskIncrementTick>
    15ce:	88 23       	and	r24, r24
    15d0:	19 f0       	breq	.+6      	; 0x15d8 <xTaskResumeAll+0xae>
    15d2:	81 e0       	ldi	r24, 0x01	; 1
    15d4:	80 93 d2 07 	sts	0x07D2, r24	; 0x8007d2 <xYieldPending>
    15d8:	c1 50       	subi	r28, 0x01	; 1
    15da:	c1 f7       	brne	.-16     	; 0x15cc <xTaskResumeAll+0xa2>
    15dc:	10 92 d3 07 	sts	0x07D3, r1	; 0x8007d3 <uxPendedTicks>
    15e0:	80 91 d2 07 	lds	r24, 0x07D2	; 0x8007d2 <xYieldPending>
    15e4:	88 23       	and	r24, r24
    15e6:	29 f0       	breq	.+10     	; 0x15f2 <xTaskResumeAll+0xc8>
    15e8:	eb d9       	rcall	.-3114   	; 0x9c0 <vPortYield>
    15ea:	81 e0       	ldi	r24, 0x01	; 1
    15ec:	03 c0       	rjmp	.+6      	; 0x15f4 <xTaskResumeAll+0xca>
    15ee:	80 e0       	ldi	r24, 0x00	; 0
    15f0:	01 c0       	rjmp	.+2      	; 0x15f4 <xTaskResumeAll+0xca>
    15f2:	80 e0       	ldi	r24, 0x00	; 0
    15f4:	0f 90       	pop	r0
    15f6:	0f be       	out	0x3f, r0	; 63
    15f8:	df 91       	pop	r29
    15fa:	cf 91       	pop	r28
    15fc:	1f 91       	pop	r17
    15fe:	0f 91       	pop	r16
    1600:	08 95       	ret

00001602 <vTaskDelayUntil>:
    1602:	0f 93       	push	r16
    1604:	1f 93       	push	r17
    1606:	cf 93       	push	r28
    1608:	df 93       	push	r29
    160a:	8c 01       	movw	r16, r24
    160c:	eb 01       	movw	r28, r22
    160e:	c7 de       	rcall	.-626    	; 0x139e <vTaskSuspendAll>
    1610:	40 91 d6 07 	lds	r20, 0x07D6	; 0x8007d6 <xTickCount>
    1614:	50 91 d7 07 	lds	r21, 0x07D7	; 0x8007d7 <xTickCount+0x1>
    1618:	f8 01       	movw	r30, r16
    161a:	20 81       	ld	r18, Z
    161c:	31 81       	ldd	r19, Z+1	; 0x01
    161e:	c9 01       	movw	r24, r18
    1620:	8c 0f       	add	r24, r28
    1622:	9d 1f       	adc	r25, r29
    1624:	42 17       	cp	r20, r18
    1626:	53 07       	cpc	r21, r19
    1628:	40 f4       	brcc	.+16     	; 0x163a <vTaskDelayUntil+0x38>
    162a:	82 17       	cp	r24, r18
    162c:	93 07       	cpc	r25, r19
    162e:	68 f4       	brcc	.+26     	; 0x164a <vTaskDelayUntil+0x48>
    1630:	48 17       	cp	r20, r24
    1632:	59 07       	cpc	r21, r25
    1634:	60 f0       	brcs	.+24     	; 0x164e <vTaskDelayUntil+0x4c>
    1636:	20 e0       	ldi	r18, 0x00	; 0
    1638:	0f c0       	rjmp	.+30     	; 0x1658 <vTaskDelayUntil+0x56>
    163a:	82 17       	cp	r24, r18
    163c:	93 07       	cpc	r25, r19
    163e:	48 f0       	brcs	.+18     	; 0x1652 <vTaskDelayUntil+0x50>
    1640:	48 17       	cp	r20, r24
    1642:	59 07       	cpc	r21, r25
    1644:	40 f0       	brcs	.+16     	; 0x1656 <vTaskDelayUntil+0x54>
    1646:	20 e0       	ldi	r18, 0x00	; 0
    1648:	07 c0       	rjmp	.+14     	; 0x1658 <vTaskDelayUntil+0x56>
    164a:	20 e0       	ldi	r18, 0x00	; 0
    164c:	05 c0       	rjmp	.+10     	; 0x1658 <vTaskDelayUntil+0x56>
    164e:	21 e0       	ldi	r18, 0x01	; 1
    1650:	03 c0       	rjmp	.+6      	; 0x1658 <vTaskDelayUntil+0x56>
    1652:	21 e0       	ldi	r18, 0x01	; 1
    1654:	01 c0       	rjmp	.+2      	; 0x1658 <vTaskDelayUntil+0x56>
    1656:	21 e0       	ldi	r18, 0x01	; 1
    1658:	f8 01       	movw	r30, r16
    165a:	91 83       	std	Z+1, r25	; 0x01
    165c:	80 83       	st	Z, r24
    165e:	22 23       	and	r18, r18
    1660:	21 f0       	breq	.+8      	; 0x166a <vTaskDelayUntil+0x68>
    1662:	60 e0       	ldi	r22, 0x00	; 0
    1664:	84 1b       	sub	r24, r20
    1666:	95 0b       	sbc	r25, r21
    1668:	e2 dd       	rcall	.-1084   	; 0x122e <prvAddCurrentTaskToDelayedList>
    166a:	5f df       	rcall	.-322    	; 0x152a <xTaskResumeAll>
    166c:	81 11       	cpse	r24, r1
    166e:	01 c0       	rjmp	.+2      	; 0x1672 <vTaskDelayUntil+0x70>
    1670:	a7 d9       	rcall	.-3250   	; 0x9c0 <vPortYield>
    1672:	df 91       	pop	r29
    1674:	cf 91       	pop	r28
    1676:	1f 91       	pop	r17
    1678:	0f 91       	pop	r16
    167a:	08 95       	ret

0000167c <vTaskSwitchContext>:
    167c:	80 91 cb 07 	lds	r24, 0x07CB	; 0x8007cb <uxSchedulerSuspended>
    1680:	88 23       	and	r24, r24
    1682:	21 f0       	breq	.+8      	; 0x168c <vTaskSwitchContext+0x10>
    1684:	81 e0       	ldi	r24, 0x01	; 1
    1686:	80 93 d2 07 	sts	0x07D2, r24	; 0x8007d2 <xYieldPending>
    168a:	08 95       	ret
    168c:	10 92 d2 07 	sts	0x07D2, r1	; 0x8007d2 <xYieldPending>
    1690:	20 91 d5 07 	lds	r18, 0x07D5	; 0x8007d5 <uxTopReadyPriority>
    1694:	01 c0       	rjmp	.+2      	; 0x1698 <vTaskSwitchContext+0x1c>
    1696:	21 50       	subi	r18, 0x01	; 1
    1698:	82 2f       	mov	r24, r18
    169a:	90 e0       	ldi	r25, 0x00	; 0
    169c:	fc 01       	movw	r30, r24
    169e:	ee 0f       	add	r30, r30
    16a0:	ff 1f       	adc	r31, r31
    16a2:	ee 0f       	add	r30, r30
    16a4:	ff 1f       	adc	r31, r31
    16a6:	ee 0f       	add	r30, r30
    16a8:	ff 1f       	adc	r31, r31
    16aa:	e8 0f       	add	r30, r24
    16ac:	f9 1f       	adc	r31, r25
    16ae:	e8 50       	subi	r30, 0x08	; 8
    16b0:	f8 4f       	sbci	r31, 0xF8	; 248
    16b2:	30 81       	ld	r19, Z
    16b4:	33 23       	and	r19, r19
    16b6:	79 f3       	breq	.-34     	; 0x1696 <vTaskSwitchContext+0x1a>
    16b8:	ac 01       	movw	r20, r24
    16ba:	44 0f       	add	r20, r20
    16bc:	55 1f       	adc	r21, r21
    16be:	44 0f       	add	r20, r20
    16c0:	55 1f       	adc	r21, r21
    16c2:	44 0f       	add	r20, r20
    16c4:	55 1f       	adc	r21, r21
    16c6:	48 0f       	add	r20, r24
    16c8:	59 1f       	adc	r21, r25
    16ca:	df 01       	movw	r26, r30
    16cc:	01 80       	ldd	r0, Z+1	; 0x01
    16ce:	f2 81       	ldd	r31, Z+2	; 0x02
    16d0:	e0 2d       	mov	r30, r0
    16d2:	02 80       	ldd	r0, Z+2	; 0x02
    16d4:	f3 81       	ldd	r31, Z+3	; 0x03
    16d6:	e0 2d       	mov	r30, r0
    16d8:	12 96       	adiw	r26, 0x02	; 2
    16da:	fc 93       	st	X, r31
    16dc:	ee 93       	st	-X, r30
    16de:	11 97       	sbiw	r26, 0x01	; 1
    16e0:	45 50       	subi	r20, 0x05	; 5
    16e2:	58 4f       	sbci	r21, 0xF8	; 248
    16e4:	e4 17       	cp	r30, r20
    16e6:	f5 07       	cpc	r31, r21
    16e8:	29 f4       	brne	.+10     	; 0x16f4 <vTaskSwitchContext+0x78>
    16ea:	42 81       	ldd	r20, Z+2	; 0x02
    16ec:	53 81       	ldd	r21, Z+3	; 0x03
    16ee:	fd 01       	movw	r30, r26
    16f0:	52 83       	std	Z+2, r21	; 0x02
    16f2:	41 83       	std	Z+1, r20	; 0x01
    16f4:	fc 01       	movw	r30, r24
    16f6:	ee 0f       	add	r30, r30
    16f8:	ff 1f       	adc	r31, r31
    16fa:	ee 0f       	add	r30, r30
    16fc:	ff 1f       	adc	r31, r31
    16fe:	ee 0f       	add	r30, r30
    1700:	ff 1f       	adc	r31, r31
    1702:	8e 0f       	add	r24, r30
    1704:	9f 1f       	adc	r25, r31
    1706:	fc 01       	movw	r30, r24
    1708:	e8 50       	subi	r30, 0x08	; 8
    170a:	f8 4f       	sbci	r31, 0xF8	; 248
    170c:	01 80       	ldd	r0, Z+1	; 0x01
    170e:	f2 81       	ldd	r31, Z+2	; 0x02
    1710:	e0 2d       	mov	r30, r0
    1712:	86 81       	ldd	r24, Z+6	; 0x06
    1714:	97 81       	ldd	r25, Z+7	; 0x07
    1716:	90 93 26 08 	sts	0x0826, r25	; 0x800826 <pxCurrentTCB+0x1>
    171a:	80 93 25 08 	sts	0x0825, r24	; 0x800825 <pxCurrentTCB>
    171e:	20 93 d5 07 	sts	0x07D5, r18	; 0x8007d5 <uxTopReadyPriority>
    1722:	08 95       	ret

00001724 <vTaskPlaceOnEventList>:
    1724:	cf 93       	push	r28
    1726:	df 93       	push	r29
    1728:	eb 01       	movw	r28, r22
    172a:	60 91 25 08 	lds	r22, 0x0825	; 0x800825 <pxCurrentTCB>
    172e:	70 91 26 08 	lds	r23, 0x0826	; 0x800826 <pxCurrentTCB+0x1>
    1732:	64 5f       	subi	r22, 0xF4	; 244
    1734:	7f 4f       	sbci	r23, 0xFF	; 255
    1736:	49 d8       	rcall	.-3950   	; 0x7ca <vListInsert>
    1738:	61 e0       	ldi	r22, 0x01	; 1
    173a:	ce 01       	movw	r24, r28
    173c:	78 dd       	rcall	.-1296   	; 0x122e <prvAddCurrentTaskToDelayedList>
    173e:	df 91       	pop	r29
    1740:	cf 91       	pop	r28
    1742:	08 95       	ret

00001744 <xTaskRemoveFromEventList>:
    1744:	0f 93       	push	r16
    1746:	1f 93       	push	r17
    1748:	cf 93       	push	r28
    174a:	df 93       	push	r29
    174c:	dc 01       	movw	r26, r24
    174e:	15 96       	adiw	r26, 0x05	; 5
    1750:	ed 91       	ld	r30, X+
    1752:	fc 91       	ld	r31, X
    1754:	16 97       	sbiw	r26, 0x06	; 6
    1756:	c6 81       	ldd	r28, Z+6	; 0x06
    1758:	d7 81       	ldd	r29, Z+7	; 0x07
    175a:	8e 01       	movw	r16, r28
    175c:	04 5f       	subi	r16, 0xF4	; 244
    175e:	1f 4f       	sbci	r17, 0xFF	; 255
    1760:	c8 01       	movw	r24, r16
    1762:	64 d8       	rcall	.-3896   	; 0x82c <uxListRemove>
    1764:	80 91 cb 07 	lds	r24, 0x07CB	; 0x8007cb <uxSchedulerSuspended>
    1768:	81 11       	cpse	r24, r1
    176a:	1b c0       	rjmp	.+54     	; 0x17a2 <xTaskRemoveFromEventList+0x5e>
    176c:	0a 50       	subi	r16, 0x0A	; 10
    176e:	11 09       	sbc	r17, r1
    1770:	c8 01       	movw	r24, r16
    1772:	5c d8       	rcall	.-3912   	; 0x82c <uxListRemove>
    1774:	8e 89       	ldd	r24, Y+22	; 0x16
    1776:	90 91 d5 07 	lds	r25, 0x07D5	; 0x8007d5 <uxTopReadyPriority>
    177a:	98 17       	cp	r25, r24
    177c:	10 f4       	brcc	.+4      	; 0x1782 <xTaskRemoveFromEventList+0x3e>
    177e:	80 93 d5 07 	sts	0x07D5, r24	; 0x8007d5 <uxTopReadyPriority>
    1782:	90 e0       	ldi	r25, 0x00	; 0
    1784:	9c 01       	movw	r18, r24
    1786:	22 0f       	add	r18, r18
    1788:	33 1f       	adc	r19, r19
    178a:	22 0f       	add	r18, r18
    178c:	33 1f       	adc	r19, r19
    178e:	22 0f       	add	r18, r18
    1790:	33 1f       	adc	r19, r19
    1792:	82 0f       	add	r24, r18
    1794:	93 1f       	adc	r25, r19
    1796:	b8 01       	movw	r22, r16
    1798:	88 50       	subi	r24, 0x08	; 8
    179a:	98 4f       	sbci	r25, 0xF8	; 248
    179c:	0e 94 c4 03 	call	0x788	; 0x788 <vListInsertEnd>
    17a0:	05 c0       	rjmp	.+10     	; 0x17ac <xTaskRemoveFromEventList+0x68>
    17a2:	b8 01       	movw	r22, r16
    17a4:	89 ed       	ldi	r24, 0xD9	; 217
    17a6:	97 e0       	ldi	r25, 0x07	; 7
    17a8:	0e 94 c4 03 	call	0x788	; 0x788 <vListInsertEnd>
    17ac:	9e 89       	ldd	r25, Y+22	; 0x16
    17ae:	e0 91 25 08 	lds	r30, 0x0825	; 0x800825 <pxCurrentTCB>
    17b2:	f0 91 26 08 	lds	r31, 0x0826	; 0x800826 <pxCurrentTCB+0x1>
    17b6:	86 89       	ldd	r24, Z+22	; 0x16
    17b8:	89 17       	cp	r24, r25
    17ba:	20 f4       	brcc	.+8      	; 0x17c4 <xTaskRemoveFromEventList+0x80>
    17bc:	81 e0       	ldi	r24, 0x01	; 1
    17be:	80 93 d2 07 	sts	0x07D2, r24	; 0x8007d2 <xYieldPending>
    17c2:	01 c0       	rjmp	.+2      	; 0x17c6 <xTaskRemoveFromEventList+0x82>
    17c4:	80 e0       	ldi	r24, 0x00	; 0
    17c6:	df 91       	pop	r29
    17c8:	cf 91       	pop	r28
    17ca:	1f 91       	pop	r17
    17cc:	0f 91       	pop	r16
    17ce:	08 95       	ret

000017d0 <vTaskSetTimeOutState>:
    17d0:	20 91 d1 07 	lds	r18, 0x07D1	; 0x8007d1 <xNumOfOverflows>
    17d4:	fc 01       	movw	r30, r24
    17d6:	20 83       	st	Z, r18
    17d8:	20 91 d6 07 	lds	r18, 0x07D6	; 0x8007d6 <xTickCount>
    17dc:	30 91 d7 07 	lds	r19, 0x07D7	; 0x8007d7 <xTickCount+0x1>
    17e0:	32 83       	std	Z+2, r19	; 0x02
    17e2:	21 83       	std	Z+1, r18	; 0x01
    17e4:	08 95       	ret

000017e6 <xTaskCheckForTimeOut>:
    17e6:	cf 93       	push	r28
    17e8:	df 93       	push	r29
    17ea:	fc 01       	movw	r30, r24
    17ec:	0f b6       	in	r0, 0x3f	; 63
    17ee:	f8 94       	cli
    17f0:	0f 92       	push	r0
    17f2:	40 91 d6 07 	lds	r20, 0x07D6	; 0x8007d6 <xTickCount>
    17f6:	50 91 d7 07 	lds	r21, 0x07D7	; 0x8007d7 <xTickCount+0x1>
    17fa:	90 81       	ld	r25, Z
    17fc:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <xNumOfOverflows>
    1800:	98 17       	cp	r25, r24
    1802:	29 f0       	breq	.+10     	; 0x180e <xTaskCheckForTimeOut+0x28>
    1804:	81 81       	ldd	r24, Z+1	; 0x01
    1806:	92 81       	ldd	r25, Z+2	; 0x02
    1808:	48 17       	cp	r20, r24
    180a:	59 07       	cpc	r21, r25
    180c:	a8 f4       	brcc	.+42     	; 0x1838 <xTaskCheckForTimeOut+0x52>
    180e:	21 81       	ldd	r18, Z+1	; 0x01
    1810:	32 81       	ldd	r19, Z+2	; 0x02
    1812:	ca 01       	movw	r24, r20
    1814:	82 1b       	sub	r24, r18
    1816:	93 0b       	sbc	r25, r19
    1818:	eb 01       	movw	r28, r22
    181a:	a8 81       	ld	r26, Y
    181c:	b9 81       	ldd	r27, Y+1	; 0x01
    181e:	8a 17       	cp	r24, r26
    1820:	9b 07       	cpc	r25, r27
    1822:	60 f4       	brcc	.+24     	; 0x183c <xTaskCheckForTimeOut+0x56>
    1824:	cf 01       	movw	r24, r30
    1826:	24 1b       	sub	r18, r20
    1828:	35 0b       	sbc	r19, r21
    182a:	2a 0f       	add	r18, r26
    182c:	3b 1f       	adc	r19, r27
    182e:	39 83       	std	Y+1, r19	; 0x01
    1830:	28 83       	st	Y, r18
    1832:	ce df       	rcall	.-100    	; 0x17d0 <vTaskSetTimeOutState>
    1834:	80 e0       	ldi	r24, 0x00	; 0
    1836:	03 c0       	rjmp	.+6      	; 0x183e <xTaskCheckForTimeOut+0x58>
    1838:	81 e0       	ldi	r24, 0x01	; 1
    183a:	01 c0       	rjmp	.+2      	; 0x183e <xTaskCheckForTimeOut+0x58>
    183c:	81 e0       	ldi	r24, 0x01	; 1
    183e:	0f 90       	pop	r0
    1840:	0f be       	out	0x3f, r0	; 63
    1842:	df 91       	pop	r29
    1844:	cf 91       	pop	r28
    1846:	08 95       	ret

00001848 <vTaskMissedYield>:
    1848:	81 e0       	ldi	r24, 0x01	; 1
    184a:	80 93 d2 07 	sts	0x07D2, r24	; 0x8007d2 <xYieldPending>
    184e:	08 95       	ret

00001850 <ulTaskNotifyTake>:
    1850:	0f 93       	push	r16
    1852:	1f 93       	push	r17
    1854:	cf 93       	push	r28
    1856:	c8 2f       	mov	r28, r24
    1858:	cb 01       	movw	r24, r22
    185a:	0f b6       	in	r0, 0x3f	; 63
    185c:	f8 94       	cli
    185e:	0f 92       	push	r0
    1860:	e0 91 25 08 	lds	r30, 0x0825	; 0x800825 <pxCurrentTCB>
    1864:	f0 91 26 08 	lds	r31, 0x0826	; 0x800826 <pxCurrentTCB+0x1>
    1868:	41 a1       	ldd	r20, Z+33	; 0x21
    186a:	52 a1       	ldd	r21, Z+34	; 0x22
    186c:	63 a1       	ldd	r22, Z+35	; 0x23
    186e:	74 a1       	ldd	r23, Z+36	; 0x24
    1870:	45 2b       	or	r20, r21
    1872:	46 2b       	or	r20, r22
    1874:	47 2b       	or	r20, r23
    1876:	59 f4       	brne	.+22     	; 0x188e <ulTaskNotifyTake+0x3e>
    1878:	e0 91 25 08 	lds	r30, 0x0825	; 0x800825 <pxCurrentTCB>
    187c:	f0 91 26 08 	lds	r31, 0x0826	; 0x800826 <pxCurrentTCB+0x1>
    1880:	21 e0       	ldi	r18, 0x01	; 1
    1882:	25 a3       	std	Z+37, r18	; 0x25
    1884:	00 97       	sbiw	r24, 0x00	; 0
    1886:	19 f0       	breq	.+6      	; 0x188e <ulTaskNotifyTake+0x3e>
    1888:	61 e0       	ldi	r22, 0x01	; 1
    188a:	d1 dc       	rcall	.-1630   	; 0x122e <prvAddCurrentTaskToDelayedList>
    188c:	99 d8       	rcall	.-3790   	; 0x9c0 <vPortYield>
    188e:	0f 90       	pop	r0
    1890:	0f be       	out	0x3f, r0	; 63
    1892:	0f b6       	in	r0, 0x3f	; 63
    1894:	f8 94       	cli
    1896:	0f 92       	push	r0
    1898:	e0 91 25 08 	lds	r30, 0x0825	; 0x800825 <pxCurrentTCB>
    189c:	f0 91 26 08 	lds	r31, 0x0826	; 0x800826 <pxCurrentTCB+0x1>
    18a0:	61 a1       	ldd	r22, Z+33	; 0x21
    18a2:	72 a1       	ldd	r23, Z+34	; 0x22
    18a4:	83 a1       	ldd	r24, Z+35	; 0x23
    18a6:	94 a1       	ldd	r25, Z+36	; 0x24
    18a8:	61 15       	cp	r22, r1
    18aa:	71 05       	cpc	r23, r1
    18ac:	81 05       	cpc	r24, r1
    18ae:	91 05       	cpc	r25, r1
    18b0:	c9 f0       	breq	.+50     	; 0x18e4 <ulTaskNotifyTake+0x94>
    18b2:	cc 23       	and	r28, r28
    18b4:	49 f0       	breq	.+18     	; 0x18c8 <ulTaskNotifyTake+0x78>
    18b6:	e0 91 25 08 	lds	r30, 0x0825	; 0x800825 <pxCurrentTCB>
    18ba:	f0 91 26 08 	lds	r31, 0x0826	; 0x800826 <pxCurrentTCB+0x1>
    18be:	11 a2       	std	Z+33, r1	; 0x21
    18c0:	12 a2       	std	Z+34, r1	; 0x22
    18c2:	13 a2       	std	Z+35, r1	; 0x23
    18c4:	14 a2       	std	Z+36, r1	; 0x24
    18c6:	0e c0       	rjmp	.+28     	; 0x18e4 <ulTaskNotifyTake+0x94>
    18c8:	e0 91 25 08 	lds	r30, 0x0825	; 0x800825 <pxCurrentTCB>
    18cc:	f0 91 26 08 	lds	r31, 0x0826	; 0x800826 <pxCurrentTCB+0x1>
    18d0:	8b 01       	movw	r16, r22
    18d2:	9c 01       	movw	r18, r24
    18d4:	01 50       	subi	r16, 0x01	; 1
    18d6:	11 09       	sbc	r17, r1
    18d8:	21 09       	sbc	r18, r1
    18da:	31 09       	sbc	r19, r1
    18dc:	01 a3       	std	Z+33, r16	; 0x21
    18de:	12 a3       	std	Z+34, r17	; 0x22
    18e0:	23 a3       	std	Z+35, r18	; 0x23
    18e2:	34 a3       	std	Z+36, r19	; 0x24
    18e4:	e0 91 25 08 	lds	r30, 0x0825	; 0x800825 <pxCurrentTCB>
    18e8:	f0 91 26 08 	lds	r31, 0x0826	; 0x800826 <pxCurrentTCB+0x1>
    18ec:	15 a2       	std	Z+37, r1	; 0x25
    18ee:	0f 90       	pop	r0
    18f0:	0f be       	out	0x3f, r0	; 63
    18f2:	cf 91       	pop	r28
    18f4:	1f 91       	pop	r17
    18f6:	0f 91       	pop	r16
    18f8:	08 95       	ret

000018fa <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    18fa:	ef 92       	push	r14
    18fc:	ff 92       	push	r15
    18fe:	0f 93       	push	r16
    1900:	1f 93       	push	r17
    1902:	cf 93       	push	r28
    1904:	df 93       	push	r29
    1906:	fc 01       	movw	r30, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;

		taskENTER_CRITICAL();
    1908:	0f b6       	in	r0, 0x3f	; 63
    190a:	f8 94       	cli
    190c:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    190e:	01 15       	cp	r16, r1
    1910:	11 05       	cpc	r17, r1
    1912:	49 f0       	breq	.+18     	; 0x1926 <xTaskGenericNotify+0x2c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    1914:	81 a1       	ldd	r24, Z+33	; 0x21
    1916:	92 a1       	ldd	r25, Z+34	; 0x22
    1918:	a3 a1       	ldd	r26, Z+35	; 0x23
    191a:	b4 a1       	ldd	r27, Z+36	; 0x24
    191c:	e8 01       	movw	r28, r16
    191e:	88 83       	st	Y, r24
    1920:	99 83       	std	Y+1, r25	; 0x01
    1922:	aa 83       	std	Y+2, r26	; 0x02
    1924:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    1926:	85 a1       	ldd	r24, Z+37	; 0x25

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    1928:	92 e0       	ldi	r25, 0x02	; 2
    192a:	95 a3       	std	Z+37, r25	; 0x25

			switch( eAction )
    192c:	22 30       	cpi	r18, 0x02	; 2
    192e:	b9 f0       	breq	.+46     	; 0x195e <xTaskGenericNotify+0x64>
    1930:	18 f4       	brcc	.+6      	; 0x1938 <xTaskGenericNotify+0x3e>
    1932:	21 30       	cpi	r18, 0x01	; 1
    1934:	31 f0       	breq	.+12     	; 0x1942 <xTaskGenericNotify+0x48>
    1936:	2f c0       	rjmp	.+94     	; 0x1996 <xTaskGenericNotify+0x9c>
    1938:	23 30       	cpi	r18, 0x03	; 3
    193a:	f9 f0       	breq	.+62     	; 0x197a <xTaskGenericNotify+0x80>
    193c:	24 30       	cpi	r18, 0x04	; 4
    193e:	19 f1       	breq	.+70     	; 0x1986 <xTaskGenericNotify+0x8c>
    1940:	2a c0       	rjmp	.+84     	; 0x1996 <xTaskGenericNotify+0x9c>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    1942:	01 a1       	ldd	r16, Z+33	; 0x21
    1944:	12 a1       	ldd	r17, Z+34	; 0x22
    1946:	23 a1       	ldd	r18, Z+35	; 0x23
    1948:	34 a1       	ldd	r19, Z+36	; 0x24
    194a:	40 2b       	or	r20, r16
    194c:	51 2b       	or	r21, r17
    194e:	62 2b       	or	r22, r18
    1950:	73 2b       	or	r23, r19
    1952:	41 a3       	std	Z+33, r20	; 0x21
    1954:	52 a3       	std	Z+34, r21	; 0x22
    1956:	63 a3       	std	Z+35, r22	; 0x23
    1958:	74 a3       	std	Z+36, r23	; 0x24
#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    195a:	11 e0       	ldi	r17, 0x01	; 1

			switch( eAction )
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;
    195c:	1f c0       	rjmp	.+62     	; 0x199c <xTaskGenericNotify+0xa2>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    195e:	41 a1       	ldd	r20, Z+33	; 0x21
    1960:	52 a1       	ldd	r21, Z+34	; 0x22
    1962:	63 a1       	ldd	r22, Z+35	; 0x23
    1964:	74 a1       	ldd	r23, Z+36	; 0x24
    1966:	4f 5f       	subi	r20, 0xFF	; 255
    1968:	5f 4f       	sbci	r21, 0xFF	; 255
    196a:	6f 4f       	sbci	r22, 0xFF	; 255
    196c:	7f 4f       	sbci	r23, 0xFF	; 255
    196e:	41 a3       	std	Z+33, r20	; 0x21
    1970:	52 a3       	std	Z+34, r21	; 0x22
    1972:	63 a3       	std	Z+35, r22	; 0x23
    1974:	74 a3       	std	Z+36, r23	; 0x24
#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    1976:	11 e0       	ldi	r17, 0x01	; 1
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
					break;
    1978:	11 c0       	rjmp	.+34     	; 0x199c <xTaskGenericNotify+0xa2>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    197a:	41 a3       	std	Z+33, r20	; 0x21
    197c:	52 a3       	std	Z+34, r21	; 0x22
    197e:	63 a3       	std	Z+35, r22	; 0x23
    1980:	74 a3       	std	Z+36, r23	; 0x24
#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    1982:	11 e0       	ldi	r17, 0x01	; 1
					( pxTCB->ulNotifiedValue )++;
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;
    1984:	0b c0       	rjmp	.+22     	; 0x199c <xTaskGenericNotify+0xa2>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    1986:	82 30       	cpi	r24, 0x02	; 2
    1988:	41 f0       	breq	.+16     	; 0x199a <xTaskGenericNotify+0xa0>
					{
						pxTCB->ulNotifiedValue = ulValue;
    198a:	41 a3       	std	Z+33, r20	; 0x21
    198c:	52 a3       	std	Z+34, r21	; 0x22
    198e:	63 a3       	std	Z+35, r22	; 0x23
    1990:	74 a3       	std	Z+36, r23	; 0x24
#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    1992:	11 e0       	ldi	r17, 0x01	; 1
    1994:	03 c0       	rjmp	.+6      	; 0x199c <xTaskGenericNotify+0xa2>
    1996:	11 e0       	ldi	r17, 0x01	; 1
    1998:	01 c0       	rjmp	.+2      	; 0x199c <xTaskGenericNotify+0xa2>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    199a:	10 e0       	ldi	r17, 0x00	; 0

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    199c:	81 30       	cpi	r24, 0x01	; 1
    199e:	41 f5       	brne	.+80     	; 0x19f0 <xTaskGenericNotify+0xf6>
    19a0:	ef 01       	movw	r28, r30
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    19a2:	7f 01       	movw	r14, r30
    19a4:	82 e0       	ldi	r24, 0x02	; 2
    19a6:	e8 0e       	add	r14, r24
    19a8:	f1 1c       	adc	r15, r1
    19aa:	c7 01       	movw	r24, r14
    19ac:	0e 94 16 04 	call	0x82c	; 0x82c <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    19b0:	8e 89       	ldd	r24, Y+22	; 0x16
    19b2:	90 91 d5 07 	lds	r25, 0x07D5	; 0x8007d5 <uxTopReadyPriority>
    19b6:	98 17       	cp	r25, r24
    19b8:	10 f4       	brcc	.+4      	; 0x19be <xTaskGenericNotify+0xc4>
    19ba:	80 93 d5 07 	sts	0x07D5, r24	; 0x8007d5 <uxTopReadyPriority>
    19be:	90 e0       	ldi	r25, 0x00	; 0
    19c0:	9c 01       	movw	r18, r24
    19c2:	22 0f       	add	r18, r18
    19c4:	33 1f       	adc	r19, r19
    19c6:	22 0f       	add	r18, r18
    19c8:	33 1f       	adc	r19, r19
    19ca:	22 0f       	add	r18, r18
    19cc:	33 1f       	adc	r19, r19
    19ce:	82 0f       	add	r24, r18
    19d0:	93 1f       	adc	r25, r19
    19d2:	b7 01       	movw	r22, r14
    19d4:	88 50       	subi	r24, 0x08	; 8
    19d6:	98 4f       	sbci	r25, 0xF8	; 248
    19d8:	0e 94 c4 03 	call	0x788	; 0x788 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    19dc:	9e 89       	ldd	r25, Y+22	; 0x16
    19de:	e0 91 25 08 	lds	r30, 0x0825	; 0x800825 <pxCurrentTCB>
    19e2:	f0 91 26 08 	lds	r31, 0x0826	; 0x800826 <pxCurrentTCB+0x1>
    19e6:	86 89       	ldd	r24, Z+22	; 0x16
    19e8:	89 17       	cp	r24, r25
    19ea:	10 f4       	brcc	.+4      	; 0x19f0 <xTaskGenericNotify+0xf6>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    19ec:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    19f0:	0f 90       	pop	r0
    19f2:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    19f4:	81 2f       	mov	r24, r17
    19f6:	df 91       	pop	r29
    19f8:	cf 91       	pop	r28
    19fa:	1f 91       	pop	r17
    19fc:	0f 91       	pop	r16
    19fe:	ff 90       	pop	r15
    1a00:	ef 90       	pop	r14
    1a02:	08 95       	ret

00001a04 <memcpy>:
    1a04:	fb 01       	movw	r30, r22
    1a06:	dc 01       	movw	r26, r24
    1a08:	02 c0       	rjmp	.+4      	; 0x1a0e <memcpy+0xa>
    1a0a:	01 90       	ld	r0, Z+
    1a0c:	0d 92       	st	X+, r0
    1a0e:	41 50       	subi	r20, 0x01	; 1
    1a10:	50 40       	sbci	r21, 0x00	; 0
    1a12:	d8 f7       	brcc	.-10     	; 0x1a0a <memcpy+0x6>
    1a14:	08 95       	ret

00001a16 <__itoa_ncheck>:
    1a16:	bb 27       	eor	r27, r27
    1a18:	4a 30       	cpi	r20, 0x0A	; 10
    1a1a:	31 f4       	brne	.+12     	; 0x1a28 <__itoa_ncheck+0x12>
    1a1c:	99 23       	and	r25, r25
    1a1e:	22 f4       	brpl	.+8      	; 0x1a28 <__itoa_ncheck+0x12>
    1a20:	bd e2       	ldi	r27, 0x2D	; 45
    1a22:	90 95       	com	r25
    1a24:	81 95       	neg	r24
    1a26:	9f 4f       	sbci	r25, 0xFF	; 255
    1a28:	01 c0       	rjmp	.+2      	; 0x1a2c <__utoa_common>

00001a2a <__utoa_ncheck>:
    1a2a:	bb 27       	eor	r27, r27

00001a2c <__utoa_common>:
    1a2c:	fb 01       	movw	r30, r22
    1a2e:	55 27       	eor	r21, r21
    1a30:	aa 27       	eor	r26, r26
    1a32:	88 0f       	add	r24, r24
    1a34:	99 1f       	adc	r25, r25
    1a36:	aa 1f       	adc	r26, r26
    1a38:	a4 17       	cp	r26, r20
    1a3a:	10 f0       	brcs	.+4      	; 0x1a40 <__utoa_common+0x14>
    1a3c:	a4 1b       	sub	r26, r20
    1a3e:	83 95       	inc	r24
    1a40:	50 51       	subi	r21, 0x10	; 16
    1a42:	b9 f7       	brne	.-18     	; 0x1a32 <__utoa_common+0x6>
    1a44:	a0 5d       	subi	r26, 0xD0	; 208
    1a46:	aa 33       	cpi	r26, 0x3A	; 58
    1a48:	08 f0       	brcs	.+2      	; 0x1a4c <__utoa_common+0x20>
    1a4a:	a9 5d       	subi	r26, 0xD9	; 217
    1a4c:	a1 93       	st	Z+, r26
    1a4e:	00 97       	sbiw	r24, 0x00	; 0
    1a50:	79 f7       	brne	.-34     	; 0x1a30 <__utoa_common+0x4>
    1a52:	b1 11       	cpse	r27, r1
    1a54:	b1 93       	st	Z+, r27
    1a56:	11 92       	st	Z+, r1
    1a58:	cb 01       	movw	r24, r22
    1a5a:	00 c0       	rjmp	.+0      	; 0x1a5c <strrev>

00001a5c <strrev>:
    1a5c:	dc 01       	movw	r26, r24
    1a5e:	fc 01       	movw	r30, r24
    1a60:	67 2f       	mov	r22, r23
    1a62:	71 91       	ld	r23, Z+
    1a64:	77 23       	and	r23, r23
    1a66:	e1 f7       	brne	.-8      	; 0x1a60 <strrev+0x4>
    1a68:	32 97       	sbiw	r30, 0x02	; 2
    1a6a:	04 c0       	rjmp	.+8      	; 0x1a74 <strrev+0x18>
    1a6c:	7c 91       	ld	r23, X
    1a6e:	6d 93       	st	X+, r22
    1a70:	70 83       	st	Z, r23
    1a72:	62 91       	ld	r22, -Z
    1a74:	ae 17       	cp	r26, r30
    1a76:	bf 07       	cpc	r27, r31
    1a78:	c8 f3       	brcs	.-14     	; 0x1a6c <strrev+0x10>
    1a7a:	08 95       	ret

00001a7c <_exit>:
    1a7c:	f8 94       	cli

00001a7e <__stop_program>:
    1a7e:	ff cf       	rjmp	.-2      	; 0x1a7e <__stop_program>
